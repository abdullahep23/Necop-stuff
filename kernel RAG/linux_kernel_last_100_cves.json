[
    {
        "CVE ID": "CVE-2025-21807",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock: fix queue freeze vs limits lock order in sysfs store methods\n\nqueue_attr_store() always freezes a device queue before calling the\nattribute store operation. For attributes that control queue limits, the\nstore operation will also lock the queue limits with a call to\nqueue_limits_start_update(). However, some drivers (e.g. SCSI sd) may\nneed to issue commands to a device to obtain limit values from the\nhardware with the queue limits locked. This creates a potential ABBA\ndeadlock situation if a user attempts to modify a limit (thus freezing\nthe device queue) while the device driver starts a revalidation of the\ndevice queue limits.\n\nAvoid such deadlock by not freezing the queue before calling the\n->store_limit() method in struct queue_sysfs_entry and instead use the\nqueue_limits_commit_update_frozen helper to freeze the queue after taking\nthe limits lock.\n\nThis also removes taking the sysfs lock for the store_limit method as\nit doesn't protect anything here, but creates even more nesting.\nHopefully it will go away from the actual sysfs methods entirely soon.\n\n(commit log adapted from a similar patch from  Damien Le Moal)",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/8985da5481562e96b95e94ed8e5cc9b6565eb82b",
            "https://git.kernel.org/stable/c/c99f66e4084a62a2cc401c4704a84328aeddc9ec"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21808",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: xdp: Disallow attaching device-bound programs in generic mode\n\nDevice-bound programs are used to support RX metadata kfuncs. These\nkfuncs are driver-specific and rely on the driver context to read the\nmetadata. This means they can't work in generic XDP mode. However, there\nis no check to disallow such programs from being attached in generic\nmode, in which case the metadata kfuncs will be called in an invalid\ncontext, leading to crashes.\n\nFix this by adding a check to disallow attaching device-bound programs\nin generic mode.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/3595599fa8360bb3c7afa7ee50c810b4a64106ea",
            "https://git.kernel.org/stable/c/557707906dd3e34b8a8c265f664d19f95799937e",
            "https://git.kernel.org/stable/c/5a9eae683d6c36e8a7aa31e5eb8b369e41aa66e1",
            "https://git.kernel.org/stable/c/b1bc4a35a04cbeb85b6ef5911ec015baa424989f"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21809",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc, afs: Fix peer hash locking vs RCU callback\n\nIn its address list, afs now retains pointers to and refs on one or more\nrxrpc_peer objects.  The address list is freed under RCU and at this time,\nit puts the refs on those peers.\n\nNow, when an rxrpc_peer object runs out of refs, it gets removed from the\npeer hash table and, for that, rxrpc has to take a spinlock.  However, it\nis now being called from afs's RCU cleanup, which takes place in BH\ncontext - but it is just taking an ordinary spinlock.\n\nThe put may also be called from non-BH context, and so there exists the\npossibility of deadlock if the BH-based RCU cleanup happens whilst the hash\nspinlock is held.  This led to the attached lockdep complaint.\n\nFix this by changing spinlocks of rxnet->peer_hash_lock back to\nBH-disabling locks.\n\n    ================================\n    WARNING: inconsistent lock state\n    6.13.0-rc5-build2+ #1223 Tainted: G            E\n    --------------------------------\n    inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage.\n    swapper/1/0 [HC0[0]:SC1[1]:HE1:SE0] takes:\n    ffff88810babe228 (&rxnet->peer_hash_lock){+.?.}-{3:3}, at: rxrpc_put_peer+0xcb/0x180\n    {SOFTIRQ-ON-W} state was registered at:\n      mark_usage+0x164/0x180\n      __lock_acquire+0x544/0x990\n      lock_acquire.part.0+0x103/0x280\n      _raw_spin_lock+0x2f/0x40\n      rxrpc_peer_keepalive_worker+0x144/0x440\n      process_one_work+0x486/0x7c0\n      process_scheduled_works+0x73/0x90\n      worker_thread+0x1c8/0x2a0\n      kthread+0x19b/0x1b0\n      ret_from_fork+0x24/0x40\n      ret_from_fork_asm+0x1a/0x30\n    irq event stamp: 972402\n    hardirqs last  enabled at (972402): [<ffffffff8244360e>] _raw_spin_unlock_irqrestore+0x2e/0x50\n    hardirqs last disabled at (972401): [<ffffffff82443328>] _raw_spin_lock_irqsave+0x18/0x60\n    softirqs last  enabled at (972300): [<ffffffff810ffbbe>] handle_softirqs+0x3ee/0x430\n    softirqs last disabled at (972313): [<ffffffff810ffc54>] __irq_exit_rcu+0x44/0x110\n\n    other info that might help us debug this:\n     Possible unsafe locking scenario:\n           CPU0\n           ----\n      lock(&rxnet->peer_hash_lock);\n      <Interrupt>\n        lock(&rxnet->peer_hash_lock);\n\n     *** DEADLOCK ***\n    1 lock held by swapper/1/0:\n     #0: ffffffff83576be0 (rcu_callback){....}-{0:0}, at: rcu_lock_acquire+0x7/0x30\n\n    stack backtrace:\n    CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Tainted: G            E      6.13.0-rc5-build2+ #1223\n    Tainted: [E]=UNSIGNED_MODULE\n    Hardware name: ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014\n    Call Trace:\n     <IRQ>\n     dump_stack_lvl+0x57/0x80\n     print_usage_bug.part.0+0x227/0x240\n     valid_state+0x53/0x70\n     mark_lock_irq+0xa5/0x2f0\n     mark_lock+0xf7/0x170\n     mark_usage+0xe1/0x180\n     __lock_acquire+0x544/0x990\n     lock_acquire.part.0+0x103/0x280\n     _raw_spin_lock+0x2f/0x40\n     rxrpc_put_peer+0xcb/0x180\n     afs_free_addrlist+0x46/0x90 [kafs]\n     rcu_do_batch+0x2d2/0x640\n     rcu_core+0x2f7/0x350\n     handle_softirqs+0x1ee/0x430\n     __irq_exit_rcu+0x44/0x110\n     irq_exit_rcu+0xa/0x30\n     sysvec_apic_timer_interrupt+0x7f/0xa0\n     </IRQ>",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/0e77dd41689637ac4e1b8fe0f27541f373640855",
            "https://git.kernel.org/stable/c/10ba5a3d57af20e494e0d979d1894260989235dd",
            "https://git.kernel.org/stable/c/79d458c13056559d49b5e41fbc4b6890e68cf65b"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21810",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndriver core: class: Fix wild pointer dereferences in API class_dev_iter_next()\n\nThere are a potential wild pointer dereferences issue regarding APIs\nclass_dev_iter_(init|next|exit)(), as explained by below typical usage:\n\n// All members of @iter are wild pointers.\nstruct class_dev_iter iter;\n\n// class_dev_iter_init(@iter, @class, ...) checks parameter @class for\n// potential class_to_subsys() error, and it returns void type and does\n// not initialize its output parameter @iter, so caller can not detect\n// the error and continues to invoke class_dev_iter_next(@iter) even if\n// @iter still contains wild pointers.\nclass_dev_iter_init(&iter, ...);\n\n// Dereference these wild pointers in @iter here once suffer the error.\nwhile (dev = class_dev_iter_next(&iter)) { ... };\n\n// Also dereference these wild pointers here.\nclass_dev_iter_exit(&iter);\n\nActually, all callers of these APIs have such usage pattern in kernel tree.\nFix by:\n- Initialize output parameter @iter by memset() in class_dev_iter_init()\n  and give callers prompt by pr_crit() for the error.\n- Check if @iter is valid in class_dev_iter_next().",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/1614e75d1a1b63db6421c7a4bf37004720c7376c",
            "https://git.kernel.org/stable/c/5c504e9767b947cf7d4e29b811c0c8b3c53242b7",
            "https://git.kernel.org/stable/c/e128f82f7006991c99a58114f70ef61e937b1ac1",
            "https://git.kernel.org/stable/c/f4b9bc823b0cfdebfed479c0e87d6939c7562e87"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21811",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: protect access to buffers with no active references\n\nnilfs_lookup_dirty_data_buffers(), which iterates through the buffers\nattached to dirty data folios/pages, accesses the attached buffers without\nlocking the folios/pages.\n\nFor data cache, nilfs_clear_folio_dirty() may be called asynchronously\nwhen the file system degenerates to read only, so\nnilfs_lookup_dirty_data_buffers() still has the potential to cause use\nafter free issues when buffers lose the protection of their dirty state\nmidway due to this asynchronous clearing and are unintentionally freed by\ntry_to_free_buffers().\n\nEliminate this race issue by adjusting the lock section in this function.",
        "Severity": "HIGH",
        "Patches": [
            "https://git.kernel.org/stable/c/367a9bffabe08c04f6d725032cce3d891b2b9e1a",
            "https://git.kernel.org/stable/c/4b08d23d7d1917bef4fbee8ad81372f49b006656",
            "https://git.kernel.org/stable/c/58c27fa7a610b6e8d44e6220e7dbddfbaccaf439",
            "https://git.kernel.org/stable/c/72cf688d0ce7e642b12ddc9b2a42524737ec1b4a",
            "https://git.kernel.org/stable/c/8e1b9201c9a24638cf09c6e1c9f224157328010b",
            "https://git.kernel.org/stable/c/c437dfac9f7a5a46ac2a5e6d6acd3059e9f68188",
            "https://git.kernel.org/stable/c/d8ff250e085a4c4cdda4ad1cdd234ed110393143",
            "https://git.kernel.org/stable/c/e1fc4a90a90ea8514246c45435662531975937d9"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21812",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nax25: rcu protect dev->ax25_ptr\n\nsyzbot found a lockdep issue [1].\n\nWe should remove ax25 RTNL dependency in ax25_setsockopt()\n\nThis should also fix a variety of possible UAF in ax25.\n\n[1]\n\nWARNING: possible circular locking dependency detected\n6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Not tainted\n------------------------------------------------------\nsyz.5.1818/12806 is trying to acquire lock:\n ffffffff8fcb3988 (rtnl_mutex){+.+.}-{4:4}, at: ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680\n\nbut task is already holding lock:\n ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline]\n ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (sk_lock-AF_AX25){+.+.}-{0:0}:\n        lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849\n        lock_sock_nested+0x48/0x100 net/core/sock.c:3642\n        lock_sock include/net/sock.h:1618 [inline]\n        ax25_kill_by_device net/ax25/af_ax25.c:101 [inline]\n        ax25_device_event+0x24d/0x580 net/ax25/af_ax25.c:146\n        notifier_call_chain+0x1a5/0x3f0 kernel/notifier.c:85\n       __dev_notify_flags+0x207/0x400\n        dev_change_flags+0xf0/0x1a0 net/core/dev.c:9026\n        dev_ifsioc+0x7c8/0xe70 net/core/dev_ioctl.c:563\n        dev_ioctl+0x719/0x1340 net/core/dev_ioctl.c:820\n        sock_do_ioctl+0x240/0x460 net/socket.c:1234\n        sock_ioctl+0x626/0x8e0 net/socket.c:1339\n        vfs_ioctl fs/ioctl.c:51 [inline]\n        __do_sys_ioctl fs/ioctl.c:906 [inline]\n        __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892\n        do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n        do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n-> #0 (rtnl_mutex){+.+.}-{4:4}:\n        check_prev_add kernel/locking/lockdep.c:3161 [inline]\n        check_prevs_add kernel/locking/lockdep.c:3280 [inline]\n        validate_chain+0x18ef/0x5920 kernel/locking/lockdep.c:3904\n        __lock_acquire+0x1397/0x2100 kernel/locking/lockdep.c:5226\n        lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849\n        __mutex_lock_common kernel/locking/mutex.c:585 [inline]\n        __mutex_lock+0x1ac/0xee0 kernel/locking/mutex.c:735\n        ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680\n        do_sock_setsockopt+0x3af/0x720 net/socket.c:2324\n        __sys_setsockopt net/socket.c:2349 [inline]\n        __do_sys_setsockopt net/socket.c:2355 [inline]\n        __se_sys_setsockopt net/socket.c:2352 [inline]\n        __x64_sys_setsockopt+0x1ee/0x280 net/socket.c:2352\n        do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n        do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(sk_lock-AF_AX25);\n                               lock(rtnl_mutex);\n                               lock(sk_lock-AF_AX25);\n  lock(rtnl_mutex);\n\n *** DEADLOCK ***\n\n1 lock held by syz.5.1818/12806:\n  #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline]\n  #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574\n\nstack backtrace:\nCPU: 1 UID: 0 PID: 12806 Comm: syz.5.1818 Not tainted 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:94 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n  print_circular_bug+0x13a/0x1b0 kernel/locking/lockdep.c:2074\n  check_noncircular+0x36a/0x4a0 kernel/locking/lockdep.c:2206\n  check_prev_add kernel/locking/lockdep.c:3161 [inline]\n  check_prevs_add kernel/lockin\n---truncated---",
        "Severity": "HIGH",
        "Patches": [
            "https://git.kernel.org/stable/c/2802ed4ced27ebd474828fc67ffd7d66f11e3605",
            "https://git.kernel.org/stable/c/7705d8a7f2c26c80973c81093db07c6022b2b30e",
            "https://git.kernel.org/stable/c/8937f5e38a218531dce2a89fae60e3adcc2311e1",
            "https://git.kernel.org/stable/c/95fc45d1dea8e1253f8ec58abc5befb71553d666",
            "https://git.kernel.org/stable/c/c2531db6de3c95551be58878f859c6a053b7eb2e"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21813",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntimers/migration: Fix off-by-one root mis-connection\n\nBefore attaching a new root to the old root, the children counter of the\nnew root is checked to verify that only the upcoming CPU's top group have\nbeen connected to it. However since the recently added commit b729cc1ec21a\n(\"timers/migration: Fix another race between hotplug and idle entry/exit\")\nthis check is not valid anymore because the old root is pre-accounted\nas a child to the new root. Therefore after connecting the upcoming\nCPU's top group to the new root, the children count to be expected must\nbe 2 and not 1 anymore.\n\nThis omission results in the old root to not be connected to the new\nroot. Then eventually the system may run with more than one top level,\nwhich defeats the purpose of a single idle migrator.\n\nAlso the old root is pre-accounted but not connected upon the new root\ncreation. But it can be connected to the new root later on. Therefore\nthe old root may be accounted twice to the new root. The propagation of\nsuch overcommit can end up creating a double final top-level root with a\ngroupmask incorrectly initialized. Although harmless given that the final\ntop level roots will never have a parent to walk up to, this oddity\nopportunistically reported the core issue:\n\n  WARNING: CPU: 8 PID: 0 at kernel/time/timer_migration.c:543 tmigr_requires_handle_remote\n  CPU: 8 UID: 0 PID: 0 Comm: swapper/8\n  RIP: 0010:tmigr_requires_handle_remote\n  Call Trace:\n   <IRQ>\n   ? tmigr_requires_handle_remote\n   ? hrtimer_run_queues\n   update_process_times\n   tick_periodic\n   tick_handle_periodic\n   __sysvec_apic_timer_interrupt\n   sysvec_apic_timer_interrupt\n  </IRQ>\n\nFix the problem by taking the old root into account in the children count\nof the new root so the connection is not omitted.\n\nAlso warn when more than one top level group exists to better detect\nsimilar issues in the future.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/6f449d8fa1808a7f9ee644866bbc079285dbefdd",
            "https://git.kernel.org/stable/c/868c9037df626b3c245ee26a290a03ae1f9f58d3",
            "https://git.kernel.org/stable/c/c6dd70e5b465a2b77c7a7c3d868736d302e29aec"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21814",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nptp: Ensure info->enable callback is always set\n\nThe ioctl and sysfs handlers unconditionally call the ->enable callback.\nNot all drivers implement that callback, leading to NULL dereferences.\nExample of affected drivers: ptp_s390.c, ptp_vclock.c and ptp_mock.c.\n\nInstead use a dummy callback if no better was specified by the driver.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/1334c64a5d1de6666e0c9f984db6745083df1eb4",
            "https://git.kernel.org/stable/c/5d1041c76de656f9f8d5a192218039a9acf9bd00",
            "https://git.kernel.org/stable/c/755caf4ee1c615ee5717862e427124370f46b1f3",
            "https://git.kernel.org/stable/c/81846070cba17125a866e8023c01d3465b153339",
            "https://git.kernel.org/stable/c/8441aea46445252df5d2eed6deb6d5246fc24002",
            "https://git.kernel.org/stable/c/9df3a9284f39bfd51a9f72a6a165c79e2aa5066b",
            "https://git.kernel.org/stable/c/fd53aa40e65f518453115b6f56183b0c201db26b",
            "https://git.kernel.org/stable/c/fdc1e72487781dd7705bcbe30878bee7d5d1f3e8"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21815",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/compaction: fix UBSAN shift-out-of-bounds warning\n\nsyzkaller reported a UBSAN shift-out-of-bounds warning of (1UL << order)\nin isolate_freepages_block().  The bogus compound_order can be any value\nbecause it is union with flags.  Add back the MAX_PAGE_ORDER check to fix\nthe warning.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/10b7d3eb535098ccd4c82a182a33655d8a0e5c88",
            "https://git.kernel.org/stable/c/4491159774d973a9e2e998d25d8fbb20fada6dfa",
            "https://git.kernel.org/stable/c/d1366e74342e75555af2648a2964deb2d5c92200"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21816",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhrtimers: Force migrate away hrtimers queued after CPUHP_AP_HRTIMERS_DYING\n\nhrtimers are migrated away from the dying CPU to any online target at\nthe CPUHP_AP_HRTIMERS_DYING stage in order not to delay bandwidth timers\nhandling tasks involved in the CPU hotplug forward progress.\n\nHowever wakeups can still be performed by the outgoing CPU after\nCPUHP_AP_HRTIMERS_DYING. Those can result again in bandwidth timers being\narmed. Depending on several considerations (crystal ball power management\nbased election, earliest timer already enqueued, timer migration enabled or\nnot), the target may eventually be the current CPU even if offline. If that\nhappens, the timer is eventually ignored.\n\nThe most notable example is RCU which had to deal with each and every of\nthose wake-ups by deferring them to an online CPU, along with related\nworkarounds:\n\n_ e787644caf76 (rcu: Defer RCU kthreads wakeup when CPU is dying)\n_ 9139f93209d1 (rcu/nocb: Fix RT throttling hrtimer armed from offline CPU)\n_ f7345ccc62a4 (rcu/nocb: Fix rcuog wake-up from offline softirq)\n\nThe problem isn't confined to RCU though as the stop machine kthread\n(which runs CPUHP_AP_HRTIMERS_DYING) reports its completion at the end\nof its work through cpu_stop_signal_done() and performs a wake up that\neventually arms the deadline server timer:\n\n   WARNING: CPU: 94 PID: 588 at kernel/time/hrtimer.c:1086 hrtimer_start_range_ns+0x289/0x2d0\n   CPU: 94 UID: 0 PID: 588 Comm: migration/94 Not tainted\n   Stopper: multi_cpu_stop+0x0/0x120 <- stop_machine_cpuslocked+0x66/0xc0\n   RIP: 0010:hrtimer_start_range_ns+0x289/0x2d0\n   Call Trace:\n   <TASK>\n     start_dl_timer\n     enqueue_dl_entity\n     dl_server_start\n     enqueue_task_fair\n     enqueue_task\n     ttwu_do_activate\n     try_to_wake_up\n     complete\n     cpu_stopper_thread\n\nInstead of providing yet another bandaid to work around the situation, fix\nit in the hrtimers infrastructure instead: always migrate away a timer to\nan online target whenever it is enqueued from an offline CPU.\n\nThis will also allow to revert all the above RCU disgraceful hacks.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/2aecec58e9040ce3d2694707889f9914a2374955",
            "https://git.kernel.org/stable/c/53dac345395c0d2493cbc2f4c85fe38aef5b63f5",
            "https://git.kernel.org/stable/c/e456a88bddae4030ba962447bb84be6669f2a0c1"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21817",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock: mark GFP_NOIO around sysfs ->store()\n\nsysfs ->store is called with queue freezed, meantime we have several\n->store() callbacks(update_nr_requests, wbt, scheduler) to allocate\nmemory with GFP_KERNEL which may run into direct reclaim code path,\nthen potential deadlock can be caused.\n\nFix the issue by marking NOIO around sysfs ->store()",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/2566ce907e5d5db8a039647208e029ce559baa31",
            "https://git.kernel.org/stable/c/7c0be4ead1f8f5f8be0803f347de0de81e3b8e1c"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21819",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRevert \"drm/amd/display: Use HW lock mgr for PSR1\"\n\nThis reverts commit\na2b5a9956269 (\"drm/amd/display: Use HW lock mgr for PSR1\")\n\nBecause it may cause system hang while connect with two edp panel.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/915697c2e69ac8d14dad498e6d6f43dbb7de3787",
            "https://git.kernel.org/stable/c/95c75578c420110c43791295985abb961d6dc033",
            "https://git.kernel.org/stable/c/a978864653e45d2671f99b09afcc1110e45d3dd9",
            "https://git.kernel.org/stable/c/dcc3f2c06d80da39eee742b51ddf0781affb260c",
            "https://git.kernel.org/stable/c/f245b400a223a71d6d5f4c72a2cb9b573a7fc2b6"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21820",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: xilinx_uartps: split sysrq handling\n\nlockdep detects the following circular locking dependency:\n\nCPU 0                      CPU 1\n========================== ============================\ncdns_uart_isr()            printk()\n  uart_port_lock(port)       console_lock()\n\t\t\t     cdns_uart_console_write()\n                               if (!port->sysrq)\n                                 uart_port_lock(port)\n  uart_handle_break()\n    port->sysrq = ...\n  uart_handle_sysrq_char()\n    printk()\n      console_lock()\n\nThe fixed commit attempts to avoid this situation by only taking the\nport lock in cdns_uart_console_write if port->sysrq unset. However, if\n(as shown above) cdns_uart_console_write runs before port->sysrq is set,\nthen it will try to take the port lock anyway. This may result in a\ndeadlock.\n\nFix this by splitting sysrq handling into two parts. We use the prepare\nhelper under the port lock and defer handling until we release the lock.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/4410dba9807a17a93f649a9f5870ceaf30a675a3",
            "https://git.kernel.org/stable/c/8ea0e7b3d7b8f2f0fc9db491ff22a0abe120801c",
            "https://git.kernel.org/stable/c/9b88a7c4584ba67267a051069b8abe44fc9595b2",
            "https://git.kernel.org/stable/c/b06f388994500297bb91be60ffaf6825ecfd2afe",
            "https://git.kernel.org/stable/c/de5bd24197bd9ee37ec1e379a3d882bbd15c5065",
            "https://git.kernel.org/stable/c/e22a97700901ba5e8bf8db68056a0d50f9440cae"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21821",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: omap: use threaded IRQ for LCD DMA\n\nWhen using touchscreen and framebuffer, Nokia 770 crashes easily with:\n\n    BUG: scheduling while atomic: irq/144-ads7846/82/0x00010000\n    Modules linked in: usb_f_ecm g_ether usb_f_rndis u_ether libcomposite configfs omap_udc ohci_omap ohci_hcd\n    CPU: 0 UID: 0 PID: 82 Comm: irq/144-ads7846 Not tainted 6.12.7-770 #2\n    Hardware name: Nokia 770\n    Call trace:\n     unwind_backtrace from show_stack+0x10/0x14\n     show_stack from dump_stack_lvl+0x54/0x5c\n     dump_stack_lvl from __schedule_bug+0x50/0x70\n     __schedule_bug from __schedule+0x4d4/0x5bc\n     __schedule from schedule+0x34/0xa0\n     schedule from schedule_preempt_disabled+0xc/0x10\n     schedule_preempt_disabled from __mutex_lock.constprop.0+0x218/0x3b4\n     __mutex_lock.constprop.0 from clk_prepare_lock+0x38/0xe4\n     clk_prepare_lock from clk_set_rate+0x18/0x154\n     clk_set_rate from sossi_read_data+0x4c/0x168\n     sossi_read_data from hwa742_read_reg+0x5c/0x8c\n     hwa742_read_reg from send_frame_handler+0xfc/0x300\n     send_frame_handler from process_pending_requests+0x74/0xd0\n     process_pending_requests from lcd_dma_irq_handler+0x50/0x74\n     lcd_dma_irq_handler from __handle_irq_event_percpu+0x44/0x130\n     __handle_irq_event_percpu from handle_irq_event+0x28/0x68\n     handle_irq_event from handle_level_irq+0x9c/0x170\n     handle_level_irq from generic_handle_domain_irq+0x2c/0x3c\n     generic_handle_domain_irq from omap1_handle_irq+0x40/0x8c\n     omap1_handle_irq from generic_handle_arch_irq+0x28/0x3c\n     generic_handle_arch_irq from call_with_stack+0x1c/0x24\n     call_with_stack from __irq_svc+0x94/0xa8\n    Exception stack(0xc5255da0 to 0xc5255de8)\n    5da0: 00000001 c22fc620 00000000 00000000 c08384a8 c106fc00 00000000 c240c248\n    5dc0: c113a600 c3f6ec30 00000001 00000000 c22fc620 c5255df0 c22fc620 c0279a94\n    5de0: 60000013 ffffffff\n     __irq_svc from clk_prepare_lock+0x4c/0xe4\n     clk_prepare_lock from clk_get_rate+0x10/0x74\n     clk_get_rate from uwire_setup_transfer+0x40/0x180\n     uwire_setup_transfer from spi_bitbang_transfer_one+0x2c/0x9c\n     spi_bitbang_transfer_one from spi_transfer_one_message+0x2d0/0x664\n     spi_transfer_one_message from __spi_pump_transfer_message+0x29c/0x498\n     __spi_pump_transfer_message from __spi_sync+0x1f8/0x2e8\n     __spi_sync from spi_sync+0x24/0x40\n     spi_sync from ads7846_halfd_read_state+0x5c/0x1c0\n     ads7846_halfd_read_state from ads7846_irq+0x58/0x348\n     ads7846_irq from irq_thread_fn+0x1c/0x78\n     irq_thread_fn from irq_thread+0x120/0x228\n     irq_thread from kthread+0xc8/0xe8\n     kthread from ret_from_fork+0x14/0x28\n\nAs a quick fix, switch to a threaded IRQ which provides a stable system.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/7bbbd311dd503653a2cc86d9226740883051dc92",
            "https://git.kernel.org/stable/c/8392ea100f0b86c234c739c6662f39f0ccc0cefd",
            "https://git.kernel.org/stable/c/aa8e22cbedeb626f2a6bda0aea362353d627cd0a",
            "https://git.kernel.org/stable/c/e4b6b665df815b4841e71b72f06446884e8aad40",
            "https://git.kernel.org/stable/c/fb6a5edb60921887d7d10619fcdcbee9759552cb"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21822",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nptp: vmclock: Set driver data before its usage\n\nIf vmclock_ptp_register() fails during probing, vmclock_remove() is\ncalled to clean up the ptp clock and misc device.\nIt uses dev_get_drvdata() to access the vmclock state.\nHowever the driver data is not yet set at this point.\n\nAssign the driver data earlier.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/6dbd8b91a065d1d8001446a28e72cd140f9acef0",
            "https://git.kernel.org/stable/c/f7d07cd4f77d77f366c8ffbb8ba8b61f614e5fce"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21823",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbatman-adv: Drop unmanaged ELP metric worker\n\nThe ELP worker needs to calculate new metric values for all neighbors\n\"reachable\" over an interface. Some of the used metric sources require\nlocks which might need to sleep. This sleep is incompatible with the RCU\nlist iterator used for the recorded neighbors. The initial approach to work\naround of this problem was to queue another work item per neighbor and then\nrun this in a new context.\n\nEven when this solved the RCU vs might_sleep() conflict, it has a major\nproblems: Nothing was stopping the work item in case it is not needed\nanymore - for example because one of the related interfaces was removed or\nthe batman-adv module was unloaded - resulting in potential invalid memory\naccesses.\n\nDirectly canceling the metric worker also has various problems:\n\n* cancel_work_sync for a to-be-deactivated interface is called with\n  rtnl_lock held. But the code in the ELP metric worker also tries to use\n  rtnl_lock() - which will never return in this case. This also means that\n  cancel_work_sync would never return because it is waiting for the worker\n  to finish.\n* iterating over the neighbor list for the to-be-deactivated interface is\n  currently done using the RCU specific methods. Which means that it is\n  possible to miss items when iterating over it without the associated\n  spinlock - a behaviour which is acceptable for a periodic metric check\n  but not for a cleanup routine (which must \"stop\" all still running\n  workers)\n\nThe better approch is to get rid of the per interface neighbor metric\nworker and handle everything in the interface worker. The original problems\nare solved by:\n\n* creating a list of neighbors which require new metric information inside\n  the RCU protected context, gathering the metric according to the new list\n  outside the RCU protected context\n* only use rcu_trylock inside metric gathering code to avoid a deadlock\n  when the cancel_delayed_work_sync is called in the interface removal code\n  (which is called with the rtnl_lock held)",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/0fdc3c166ac17b26014313fa2b93696354511b24",
            "https://git.kernel.org/stable/c/1c334629176c2d644befc31a20d4bf75542f7631",
            "https://git.kernel.org/stable/c/3c0e0aecb78cb2a2ca1dc701982d08fedb088dc6",
            "https://git.kernel.org/stable/c/781a06fd265a8151f7601122d9c2e985663828ff",
            "https://git.kernel.org/stable/c/8c8ecc98f5c65947b0070a24bac11e12e47cc65d",
            "https://git.kernel.org/stable/c/a0019971f340ae02ba54cf1861f72da7e03e6b66",
            "https://git.kernel.org/stable/c/a7aa2317285806640c844acd4cd2cd768e395264",
            "https://git.kernel.org/stable/c/af264c2a9adc37f4bdf88ca7f3affa15d8c7de9e"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21824",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpu: host1x: Fix a use of uninitialized mutex\n\ncommit c8347f915e67 (\"gpu: host1x: Fix boot regression for Tegra\")\ncaused a use of uninitialized mutex leading to below warning when\nCONFIG_DEBUG_MUTEXES and CONFIG_DEBUG_LOCK_ALLOC are enabled.\n\n[   41.662843] ------------[ cut here ]------------\n[   41.663012] DEBUG_LOCKS_WARN_ON(lock->magic != lock)\n[   41.663035] WARNING: CPU: 4 PID: 794 at kernel/locking/mutex.c:587 __mutex_lock+0x670/0x878\n[   41.663458] Modules linked in: rtw88_8822c(+) bluetooth(+) rtw88_pci rtw88_core mac80211 aquantia libarc4 crc_itu_t cfg80211 tegra194_cpufreq dwmac_tegra(+) arm_dsu_pmu stmmac_platform stmmac pcs_xpcs rfkill at24 host1x(+) tegra_bpmp_thermal ramoops reed_solomon fuse loop nfnetlink xfs mmc_block rpmb_core ucsi_ccg ina3221 crct10dif_ce xhci_tegra ghash_ce lm90 sha2_ce sha256_arm64 sha1_ce sdhci_tegra pwm_fan sdhci_pltfm sdhci gpio_keys rtc_tegra cqhci mmc_core phy_tegra_xusb i2c_tegra tegra186_gpc_dma i2c_tegra_bpmp spi_tegra114 dm_mirror dm_region_hash dm_log dm_mod\n[   41.665078] CPU: 4 UID: 0 PID: 794 Comm: (udev-worker) Not tainted 6.11.0-29.31_1538613708.el10.aarch64+debug #1\n[   41.665838] Hardware name: NVIDIA NVIDIA Jetson AGX Orin Developer Kit/Jetson, BIOS 36.3.0-gcid-35594366 02/26/2024\n[   41.672555] pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   41.679636] pc : __mutex_lock+0x670/0x878\n[   41.683834] lr : __mutex_lock+0x670/0x878\n[   41.688035] sp : ffff800084b77090\n[   41.691446] x29: ffff800084b77160 x28: ffffdd4bebf7b000 x27: ffffdd4be96b1000\n[   41.698799] x26: 1fffe0002308361c x25: 1ffff0001096ee18 x24: 0000000000000000\n[   41.706149] x23: 0000000000000000 x22: 0000000000000002 x21: ffffdd4be6e3c7a0\n[   41.713500] x20: ffff800084b770f0 x19: ffff00011841b1e8 x18: 0000000000000000\n[   41.720675] x17: 0000000000000000 x16: 0000000000000000 x15: 0720072007200720\n[   41.728023] x14: 0000000000000000 x13: 0000000000000001 x12: ffff6001a96eaab3\n[   41.735375] x11: 1fffe001a96eaab2 x10: ffff6001a96eaab2 x9 : ffffdd4be4838bbc\n[   41.742723] x8 : 00009ffe5691554e x7 : ffff000d4b755593 x6 : 0000000000000001\n[   41.749985] x5 : ffff000d4b755590 x4 : 1fffe0001d88f001 x3 : dfff800000000000\n[   41.756988] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0000ec478000\n[   41.764251] Call trace:\n[   41.766695]  __mutex_lock+0x670/0x878\n[   41.770373]  mutex_lock_nested+0x2c/0x40\n[   41.774134]  host1x_intr_start+0x54/0xf8 [host1x]\n[   41.778863]  host1x_runtime_resume+0x150/0x228 [host1x]\n[   41.783935]  pm_generic_runtime_resume+0x84/0xc8\n[   41.788485]  __rpm_callback+0xa0/0x478\n[   41.792422]  rpm_callback+0x15c/0x1a8\n[   41.795922]  rpm_resume+0x698/0xc08\n[   41.799597]  __pm_runtime_resume+0xa8/0x140\n[   41.803621]  host1x_probe+0x810/0xbc0 [host1x]\n[   41.807909]  platform_probe+0xcc/0x1a8\n[   41.811845]  really_probe+0x188/0x800\n[   41.815347]  __driver_probe_device+0x164/0x360\n[   41.819810]  driver_probe_device+0x64/0x1a8\n[   41.823834]  __driver_attach+0x180/0x490\n[   41.827773]  bus_for_each_dev+0x104/0x1a0\n[   41.831797]  driver_attach+0x44/0x68\n[   41.835296]  bus_add_driver+0x23c/0x4e8\n[   41.839235]  driver_register+0x15c/0x3a8\n[   41.843170]  __platform_register_drivers+0xa4/0x208\n[   41.848159]  tegra_host1x_init+0x4c/0xff8 [host1x]\n[   41.853147]  do_one_initcall+0xd4/0x380\n[   41.856997]  do_init_module+0x1dc/0x698\n[   41.860758]  load_module+0xc70/0x1300\n[   41.864435]  __do_sys_init_module+0x1a8/0x1d0\n[   41.868721]  __arm64_sys_init_module+0x74/0xb0\n[   41.873183]  invoke_syscall.constprop.0+0xdc/0x1e8\n[   41.877997]  do_el0_svc+0x154/0x1d0\n[   41.881671]  el0_svc+0x54/0x140\n[   41.884820]  el0t_64_sync_handler+0x120/0x130\n[   41.889285]  el0t_64_sync+0x1a4/0x1a8\n[   41.892960] irq event stamp: 69737\n[   41.896370] hardirqs last  enabled at (69737): [<ffffdd4be6d7768c>] _raw_spin_unlock_irqrestore+0x44/0xe8\n[   41.905739] hardirqs last disabled at (69736):\n---truncated---",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/02458fbfaa0170aabf8506f7d4ed054f02414251",
            "https://git.kernel.org/stable/c/127e91638ddcd02b80de92fec2240609a9f90426",
            "https://git.kernel.org/stable/c/396d8e5136b4476672bc15b83ba312486bb4bf76"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2022-49733",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: pcm: oss: Fix race at SNDCTL_DSP_SYNC\n\nThere is a small race window at snd_pcm_oss_sync() that is called from\nOSS PCM SNDCTL_DSP_SYNC ioctl; namely the function calls\nsnd_pcm_oss_make_ready() at first, then takes the params_lock mutex\nfor the rest.  When the stream is set up again by another thread\nbetween them, it leads to inconsistency, and may result in unexpected\nresults such as NULL dereference of OSS buffer as a fuzzer spotted\nrecently.\n\nThe fix is simply to cover snd_pcm_oss_make_ready() call into the same\nparams_lock mutex with snd_pcm_oss_make_ready_locked() variant.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/4051324a6dafd7053c74c475e80b3ba10ae672b0",
            "https://git.kernel.org/stable/c/723ac5ab2891b6c10dd6cc78ef5456af593490eb",
            "https://git.kernel.org/stable/c/8015ef9e8a0ee5cecfd0cb6805834d007ab26f86",
            "https://git.kernel.org/stable/c/8423f0b6d513b259fdab9c9bf4aaa6188d054c2d",
            "https://git.kernel.org/stable/c/fce793a056c604b41a298317cf704dae255f1b36"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.0:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.0:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.0:rc3:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.0:rc4:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2024-58051",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipmi: ipmb: Add check devm_kasprintf() returned value\n\ndevm_kasprintf() can return a NULL pointer on failure but this\nreturned value is not checked.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/1a8a17c5ce9cb5a82797602bff9819ac732d2ff5",
            "https://git.kernel.org/stable/c/2378bd0b264ad3a1f76bd957caf33ee0c7945351",
            "https://git.kernel.org/stable/c/312a6445036d692bc5665307eeafa4508c33c4b5",
            "https://git.kernel.org/stable/c/4c9caf86d04dcb10e9fd8cd9db8eb79b5bfcc4d8",
            "https://git.kernel.org/stable/c/a63284d415d4d114abd8be6e66a9558f3ca0702d",
            "https://git.kernel.org/stable/c/caac520350546e736894d14e051b64a9edb3600c",
            "https://git.kernel.org/stable/c/e529fbcf1f35f5fc3c839df7f06c3e3d02579715",
            "https://git.kernel.org/stable/c/eb288ab33fd87579789cb331209ff09e988ff4f7"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58052",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix potential NULL pointer dereference in atomctrl_get_smc_sclk_range_table\n\nThe function atomctrl_get_smc_sclk_range_table() does not check the return\nvalue of smu_atom_get_data_table(). If smu_atom_get_data_table() fails to\nretrieve SMU_Info table, it returns NULL which is later dereferenced.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.\n\nIn practice this should never happen as this code only gets called\non polaris chips and the vbios data table will always be present on\nthose chips.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/0b97cd8a61b2b40fd73cf92a4bb2256462d22adb",
            "https://git.kernel.org/stable/c/2396bc91935c6da0588ce07850d07897974bd350",
            "https://git.kernel.org/stable/c/357445e28ff004d7f10967aa93ddb4bffa5c3688",
            "https://git.kernel.org/stable/c/396350adf0e5ad4bf05f01e4d79bfb82f0f6c41a",
            "https://git.kernel.org/stable/c/6a30634a2e0f1dd3c6b39fd0f114c32893a9907a",
            "https://git.kernel.org/stable/c/a713ba7167c2d74c477dd7764dbbdbe3199f17f4",
            "https://git.kernel.org/stable/c/ae522ad211ec4b72eaf742b25f24b0a406afcba1",
            "https://git.kernel.org/stable/c/c47066ed7c8f3b320ef87fa6217a2b8b24e127cc"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58053",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc: Fix handling of received connection abort\n\nFix the handling of a connection abort that we've received.  Though the\nabort is at the connection level, it needs propagating to the calls on that\nconnection.  Whilst the propagation bit is performed, the calls aren't then\nwoken up to go and process their termination, and as no further input is\nforthcoming, they just hang.\n\nAlso add some tracing for the logging of connection aborts.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/0e56ebde245e4799ce74d38419426f2a80d39950",
            "https://git.kernel.org/stable/c/5842ce7b120c65624052a8da04460d35b26caac0",
            "https://git.kernel.org/stable/c/96d1d927c4d03ee9dcee7640bca70b74e63504fc",
            "https://git.kernel.org/stable/c/9c6702260557c0183d8417c79a37777a3d3e58e8"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58054",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nstaging: media: max96712: fix kernel oops when removing module\n\nThe following kernel oops is thrown when trying to remove the max96712\nmodule:\n\nUnable to handle kernel paging request at virtual address 00007375746174db\nMem abort info:\n  ESR = 0x0000000096000004\n  EC = 0x25: DABT (current EL), IL = 32 bits\n  SET = 0, FnV = 0\n  EA = 0, S1PTW = 0\n  FSC = 0x04: level 0 translation fault\nData abort info:\n  ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000\n  CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n  GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\nuser pgtable: 4k pages, 48-bit VAs, pgdp=000000010af89000\n[00007375746174db] pgd=0000000000000000, p4d=0000000000000000\nInternal error: Oops: 0000000096000004 [#1] PREEMPT SMP\nModules linked in: crct10dif_ce polyval_ce mxc_jpeg_encdec flexcan\n    snd_soc_fsl_sai snd_soc_fsl_asoc_card snd_soc_fsl_micfil dwc_mipi_csi2\n    imx_csi_formatter polyval_generic v4l2_jpeg imx_pcm_dma can_dev\n    snd_soc_imx_audmux snd_soc_wm8962 snd_soc_imx_card snd_soc_fsl_utils\n    max96712(C-) rpmsg_ctrl rpmsg_char pwm_fan fuse\n    [last unloaded: imx8_isi]\nCPU: 0 UID: 0 PID: 754 Comm: rmmod\n\t    Tainted: G         C    6.12.0-rc6-06364-g327fec852c31 #17\nTainted: [C]=CRAP\nHardware name: NXP i.MX95 19X19 board (DT)\npstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : led_put+0x1c/0x40\nlr : v4l2_subdev_put_privacy_led+0x48/0x58\nsp : ffff80008699bbb0\nx29: ffff80008699bbb0 x28: ffff00008ac233c0 x27: 0000000000000000\nx26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000\nx23: ffff000080cf1170 x22: ffff00008b53bd00 x21: ffff8000822ad1c8\nx20: ffff000080ff5c00 x19: ffff00008b53be40 x18: 0000000000000000\nx17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\nx14: 0000000000000004 x13: ffff0000800f8010 x12: 0000000000000000\nx11: ffff000082acf5c0 x10: ffff000082acf478 x9 : ffff0000800f8010\nx8 : 0101010101010101 x7 : 7f7f7f7f7f7f7f7f x6 : fefefeff6364626d\nx5 : 8080808000000000 x4 : 0000000000000020 x3 : 00000000553a3dc1\nx2 : ffff00008ac233c0 x1 : ffff00008ac233c0 x0 : ff00737574617473\nCall trace:\n led_put+0x1c/0x40\n v4l2_subdev_put_privacy_led+0x48/0x58\n v4l2_async_unregister_subdev+0x2c/0x1a4\n max96712_remove+0x1c/0x38 [max96712]\n i2c_device_remove+0x2c/0x9c\n device_remove+0x4c/0x80\n device_release_driver_internal+0x1cc/0x228\n driver_detach+0x4c/0x98\n bus_remove_driver+0x6c/0xbc\n driver_unregister+0x30/0x60\n i2c_del_driver+0x54/0x64\n max96712_i2c_driver_exit+0x18/0x1d0 [max96712]\n __arm64_sys_delete_module+0x1a4/0x290\n invoke_syscall+0x48/0x10c\n el0_svc_common.constprop.0+0xc0/0xe0\n do_el0_svc+0x1c/0x28\n el0_svc+0x34/0xd8\n el0t_64_sync_handler+0x120/0x12c\n el0t_64_sync+0x190/0x194\nCode: f9000bf3 aa0003f3 f9402800 f9402000 (f9403400)\n---[ end trace 0000000000000000 ]---\n\nThis happens because in v4l2_i2c_subdev_init(), the i2c_set_cliendata()\nis called again and the data is overwritten to point to sd, instead of\npriv. So, in remove(), the wrong pointer is passed to\nv4l2_async_unregister_subdev(), leading to a crash.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/1556b9149b81cc549c13f5e56e81e89404d8a666",
            "https://git.kernel.org/stable/c/278a98f6d8a7bbe1110433b057333536e4490edf",
            "https://git.kernel.org/stable/c/3311c5395e7322298b659b8addc704b39fb3a59c",
            "https://git.kernel.org/stable/c/dfde3d63afbaae664c4d36e53cfb4045d5374561",
            "https://git.kernel.org/stable/c/ee1b5046d5cd892a0754ab982aeaaad3702083a5"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58055",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: f_tcm: Don't free command immediately\n\nDon't prematurely free the command. Wait for the status completion of\nthe sense status. It can be freed then. Otherwise we will double-free\nthe command.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/16907219ad6763f401700e1b57b2da4f3e07f047",
            "https://git.kernel.org/stable/c/38229c35a6d7875697dfb293356407330cfcd23e",
            "https://git.kernel.org/stable/c/7cb72dc08ed8da60fd6d1f6adf13bf0e6ee0f694",
            "https://git.kernel.org/stable/c/929b69810eec132b284ffd19047a85d961df9e4d",
            "https://git.kernel.org/stable/c/bbb7f49839b57d66ccaf7b5752d9b63d3031dd0a",
            "https://git.kernel.org/stable/c/c225d006a31949d673e646d585d9569bc28feeb9",
            "https://git.kernel.org/stable/c/e6693595bd1b55af62d057a4136a89d5c2ddf0e9",
            "https://git.kernel.org/stable/c/f0c33e7d387ccbb6870e73a43c558fefede06614"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58056",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nremoteproc: core: Fix ida_free call while not allocated\n\nIn the rproc_alloc() function, on error, put_device(&rproc->dev) is\ncalled, leading to the call of the rproc_type_release() function.\nAn error can occurs before ida_alloc is called.\n\nIn such case in rproc_type_release(), the condition (rproc->index >= 0) is\ntrue as rproc->index has been  initialized to 0.\nida_free() is called reporting a warning:\n[    4.181906] WARNING: CPU: 1 PID: 24 at lib/idr.c:525 ida_free+0x100/0x164\n[    4.186378] stm32-display-dsi 5a000000.dsi: Fixed dependency cycle(s) with /soc/dsi@5a000000/panel@0\n[    4.188854] ida_free called for id=0 which is not allocated.\n[    4.198256] mipi-dsi 5a000000.dsi.0: Fixed dependency cycle(s) with /soc/dsi@5a000000\n[    4.203556] Modules linked in: panel_orisetech_otm8009a dw_mipi_dsi_stm(+) gpu_sched dw_mipi_dsi stm32_rproc stm32_crc32 stm32_ipcc(+) optee(+)\n[    4.224307] CPU: 1 UID: 0 PID: 24 Comm: kworker/u10:0 Not tainted 6.12.0 #442\n[    4.231481] Hardware name: STM32 (Device Tree Support)\n[    4.236627] Workqueue: events_unbound deferred_probe_work_func\n[    4.242504] Call trace:\n[    4.242522]  unwind_backtrace from show_stack+0x10/0x14\n[    4.250218]  show_stack from dump_stack_lvl+0x50/0x64\n[    4.255274]  dump_stack_lvl from __warn+0x80/0x12c\n[    4.260134]  __warn from warn_slowpath_fmt+0x114/0x188\n[    4.265199]  warn_slowpath_fmt from ida_free+0x100/0x164\n[    4.270565]  ida_free from rproc_type_release+0x38/0x60\n[    4.275832]  rproc_type_release from device_release+0x30/0xa0\n[    4.281601]  device_release from kobject_put+0xc4/0x294\n[    4.286762]  kobject_put from rproc_alloc.part.0+0x208/0x28c\n[    4.292430]  rproc_alloc.part.0 from devm_rproc_alloc+0x80/0xc4\n[    4.298393]  devm_rproc_alloc from stm32_rproc_probe+0xd0/0x844 [stm32_rproc]\n[    4.305575]  stm32_rproc_probe [stm32_rproc] from platform_probe+0x5c/0xbc\n\nCalling ida_alloc earlier in rproc_alloc ensures that the rproc->index is\nproperly set.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/2cf54928e7e32362215c69b68a6a53d110323bf3",
            "https://git.kernel.org/stable/c/7378aeb664e5ebc396950b36a1f2dedf5aabec20",
            "https://git.kernel.org/stable/c/b32d60a852bb3952886625d0c3b1c9a88c3ceb7c",
            "https://git.kernel.org/stable/c/e9efd9fa4679803fe23188d7b47119cf7bc2de6f",
            "https://git.kernel.org/stable/c/f2013d19b7704cd723ab42664b8d9408ea8cc77c"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58057",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nidpf: convert workqueues to unbound\n\nWhen a workqueue is created with `WQ_UNBOUND`, its work items are\nserved by special worker-pools, whose host workers are not bound to\nany specific CPU. In the default configuration (i.e. when\n`queue_delayed_work` and friends do not specify which CPU to run the\nwork item on), `WQ_UNBOUND` allows the work item to be executed on any\nCPU in the same node of the CPU it was enqueued on. While this\nsolution potentially sacrifices locality, it avoids contention with\nother processes that might dominate the CPU time of the processor the\nwork item was scheduled on.\n\nThis is not just a theoretical problem: in a particular scenario\nmisconfigured process was hogging most of the time from CPU0, leaving\nless than 0.5% of its CPU time to the kworker. The IDPF workqueues\nthat were using the kworker on CPU0 suffered large completion delays\nas a result, causing performance degradation, timeouts and eventual\nsystem crash.\n\n\n* I have also run a manual test to gauge the performance\n  improvement. The test consists of an antagonist process\n  (`./stress --cpu 2`) consuming as much of CPU 0 as possible. This\n  process is run under `taskset 01` to bind it to CPU0, and its\n  priority is changed with `chrt -pQ 9900 10000 ${pid}` and\n  `renice -n -20 ${pid}` after start.\n\n  Then, the IDPF driver is forced to prefer CPU0 by editing all calls\n  to `queue_delayed_work`, `mod_delayed_work`, etc... to use CPU 0.\n\n  Finally, `ktraces` for the workqueue events are collected.\n\n  Without the current patch, the antagonist process can force\n  arbitrary delays between `workqueue_queue_work` and\n  `workqueue_execute_start`, that in my tests were as high as\n  `30ms`. With the current patch applied, the workqueue can be\n  migrated to another unloaded CPU in the same node, and, keeping\n  everything else equal, the maximum delay I could see was `6us`.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/66bf9b3d9e1658333741f075320dc8e7cd6f8d09",
            "https://git.kernel.org/stable/c/868202ec3854e13de1164e4a3e25521194c5af72",
            "https://git.kernel.org/stable/c/9a5b021cb8186f1854bac2812bd4f396bb1e881c"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58058",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nubifs: skip dumping tnc tree when zroot is null\n\nClearing slab cache will free all znode in memory and make\nc->zroot.znode = NULL, then dumping tnc tree will access\nc->zroot.znode which cause null pointer dereference.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/1787cd67bb94b106555ffe64f887f6aa24b47010",
            "https://git.kernel.org/stable/c/2a987950df825d0144370e700dc5fb337684ffba",
            "https://git.kernel.org/stable/c/40e25a3c0063935763717877bb2a814c081509ff",
            "https://git.kernel.org/stable/c/428aff8f7cfb0d9a8854477648022cef96bcab28",
            "https://git.kernel.org/stable/c/6211c11fc20424bbc6d79c835c7c212b553ae898",
            "https://git.kernel.org/stable/c/77e5266e3d3faa6bdcf20d9c68a8972f6aa06522",
            "https://git.kernel.org/stable/c/bdb0ca39e0acccf6771db49c3f94ed787d05f2d7",
            "https://git.kernel.org/stable/c/e01b55f261ccc96e347eba4931e4429d080d879d"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58059",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: uvcvideo: Fix deadlock during uvc_probe\n\nIf uvc_probe() fails, it can end up calling uvc_status_unregister() before\nuvc_status_init() is called.\n\nFix this by checking if dev->status is NULL or not in\nuvc_status_unregister().",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/a67f75c2b5ecf534eab416ce16c11fe780c4f8f6",
            "https://git.kernel.org/stable/c/db577ededf3a18b39567fc1a6209f12a0c4a3c52"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58060",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Reject struct_ops registration that uses module ptr and the module btf_id is missing\n\nThere is a UAF report in the bpf_struct_ops when CONFIG_MODULES=n.\nIn particular, the report is on tcp_congestion_ops that has\na \"struct module *owner\" member.\n\nFor struct_ops that has a \"struct module *owner\" member,\nit can be extended either by the regular kernel module or\nby the bpf_struct_ops. bpf_try_module_get() will be used\nto do the refcounting and different refcount is done\nbased on the owner pointer. When CONFIG_MODULES=n,\nthe btf_id of the \"struct module\" is missing:\n\nWARN: resolve_btfids: unresolved symbol module\n\nThus, the bpf_try_module_get() cannot do the correct refcounting.\n\nNot all subsystem's struct_ops requires the \"struct module *owner\" member.\ne.g. the recent sched_ext_ops.\n\nThis patch is to disable bpf_struct_ops registration if\nthe struct_ops has the \"struct module *\" member and the\n\"struct module\" btf_id is missing. The btf_type_is_fwd() helper\nis moved to the btf.h header file for this test.\n\nThis has happened since the beginning of bpf_struct_ops which has gone\nthrough many changes. The Fixes tag is set to a recent commit that this\npatch can apply cleanly. Considering CONFIG_MODULES=n is not\ncommon and the age of the issue, targeting for bpf-next also.",
        "Severity": "HIGH",
        "Patches": [
            "https://git.kernel.org/stable/c/2324fb4e92092837ee278fdd8d60c48ee1a619ce",
            "https://git.kernel.org/stable/c/96ea081ed52bf077cad6d00153b6fba68e510767",
            "https://git.kernel.org/stable/c/b777b14c2a4a4e2322daf8e8ffd42d2b88831b17"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58061",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: prohibit deactivating all links\n\nIn the internal API this calls this is a WARN_ON, but that\nshould remain since internally we want to know about bugs\nthat may cause this. Prevent deactivating all links in the\ndebugfs write directly.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/18100796c11dfdea9101fdc95d2428b2093477ee",
            "https://git.kernel.org/stable/c/270ad6776e7cf1be3b769e0447070f9d0e8269db",
            "https://git.kernel.org/stable/c/7553477cbfd784b128297f9ed43751688415bbaa",
            "https://git.kernel.org/stable/c/d36e48a4d81c647df8a76cc58fd4d2442ba10744",
            "https://git.kernel.org/stable/c/dfe9a043300261afe5eadc07b867a6810c4e999a"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58062",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: mvm: avoid NULL pointer dereference\n\nWhen iterating over the links of a vif, we need to make sure that the\npointer is valid (in other words - that the link exists) before\ndereferncing it.\nUse for_each_vif_active_link that also does the check.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/7f6fb4b7611eb6371c493c42fefad84a1742bcbb",
            "https://git.kernel.org/stable/c/cf704a7624f99eb2ffca1a16c69183e85544a613",
            "https://git.kernel.org/stable/c/fbb563ad5032a07ac83c746ce5c8de5f25b5ffd0"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58063",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtlwifi: fix memory leaks and invalid access at probe error path\n\nDeinitialize at reverse order when probe fails.\n\nWhen init_sw_vars fails, rtl_deinit_core should not be called, specially\nnow that it destroys the rtl_wq workqueue.\n\nAnd call rtl_pci_deinit and deinit_sw_vars, otherwise, memory will be\nleaked.\n\nRemove pci_set_drvdata call as it will already be cleaned up by the core\ndriver code and could lead to memory leaks too. cf. commit 8d450935ae7f\n(\"wireless: rtlwifi: remove unnecessary pci_set_drvdata()\") and\ncommit 3d86b93064c7 (\"rtlwifi: Fix PCI probe error path orphaned memory\").",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/32acebca0a51f5e372536bfdc0d7d332ab749013",
            "https://git.kernel.org/stable/c/455e0f40b5352186a9095f2135d5c89255e7c39a",
            "https://git.kernel.org/stable/c/624cea89a0865a2bc3e00182a6b0f954a94328b4",
            "https://git.kernel.org/stable/c/6b76bab5c257463302c9e97f5d84d524457468eb",
            "https://git.kernel.org/stable/c/85b67b4c4a0f8a6fb20cf4ef7684ff2b0cf559df",
            "https://git.kernel.org/stable/c/b96371339fd9cac90f5ee4ac17ee5c4cbbdfa6f7",
            "https://git.kernel.org/stable/c/e7ceefbfd8d447abc8aca8ab993a942803522c06",
            "https://git.kernel.org/stable/c/ee0b0d7baa8a6d42c7988f6e50c8f164cdf3fa47"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58064",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: cfg80211: tests: Fix potential NULL dereference in test_cfg80211_parse_colocated_ap()\n\nkunit_kzalloc() may return NULL, dereferencing it without NULL check may\nlead to NULL dereference.\nAdd a NULL check for ies.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/0d17d81143f5aa56ee87e60bb1000a2372a0ada8",
            "https://git.kernel.org/stable/c/13c4f7714c6a1ecf748a2f22099447c14fe6ed8c",
            "https://git.kernel.org/stable/c/886271409603956edd09df229dde7442c410a872"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58065",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mmp: pxa1908-apbc: Fix NULL vs IS_ERR() check\n\nThe devm_kzalloc() function returns NULL on error, not error pointers.\nFix the check.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/6628f7f88de5f65f01adef5a63c707cb49d0fddb",
            "https://git.kernel.org/stable/c/e5ca5d7b4d7c29246d957dc45d63610584ae3a54"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58066",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mmp: pxa1908-apbcp: Fix a NULL vs IS_ERR() check\n\nThe devm_kzalloc() function doesn't return error pointers, it returns\nNULL on error.  Update the check to match.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/2b3a36fb572caf9fb72f158be328395b1c938bf7",
            "https://git.kernel.org/stable/c/3acea81be689b77b3ceac6ff345ff0366734d967"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58067",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mmp: pxa1908-mpmu: Fix a NULL vs IS_ERR() check\n\nThe devm_kzalloc() function returns NULL on error, not error pointers.\nUpdate the check to match.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/0869a7b2afdfcdd2beb0a5fb683119bcf39c0e9d",
            "https://git.kernel.org/stable/c/7def56f841af22e07977e193eea002e085facbdb"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58068",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nOPP: fix dev_pm_opp_find_bw_*() when bandwidth table not initialized\n\nIf a driver calls dev_pm_opp_find_bw_ceil/floor() the retrieve bandwidth\nfrom the OPP table but the bandwidth table was not created because the\ninterconnect properties were missing in the OPP consumer node, the\nkernel will crash with:\n\nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000004\n...\npc : _read_bw+0x8/0x10\nlr : _opp_table_find_key+0x9c/0x174\n...\nCall trace:\n  _read_bw+0x8/0x10 (P)\n  _opp_table_find_key+0x9c/0x174 (L)\n  _find_key+0x98/0x168\n  dev_pm_opp_find_bw_ceil+0x50/0x88\n...\n\nIn order to fix the crash, create an assert function to check\nif the bandwidth table was created before trying to get a\nbandwidth with _read_bw().",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/5165486681dbd67b61b975c63125f2a5cb7f96d1",
            "https://git.kernel.org/stable/c/84ff05c9bd577157baed711a4f0b41206593978b",
            "https://git.kernel.org/stable/c/8532fd078d2a5286915d03bb0a0893ee1955acef",
            "https://git.kernel.org/stable/c/b44b9bc7cab2967c3d6a791b1cd542c89fc07f0e",
            "https://git.kernel.org/stable/c/ff2def251849133be6076a7c2d427d8eb963c223"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58069",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrtc: pcf85063: fix potential OOB write in PCF85063 NVMEM read\n\nThe nvmem interface supports variable buffer sizes, while the regmap\ninterface operates with fixed-size storage. If an nvmem client uses a\nbuffer size less than 4 bytes, regmap_read will write out of bounds\nas it expects the buffer to point at an unsigned int.\n\nFix this by using an intermediary unsigned int to hold the value.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/21cd59fcb9952eb7505da2bdfc1eb9c619df3ff4",
            "https://git.kernel.org/stable/c/3ab8c5ed4f84fa20cd16794fe8dc31f633fbc70c",
            "https://git.kernel.org/stable/c/517aedb365f2c94e2d7e0b908ac7127df76203a1",
            "https://git.kernel.org/stable/c/6f2a8ca9a0a38589f52a7f0fb9425b9ba987ae7c",
            "https://git.kernel.org/stable/c/9adefa7b9559d0f21034a5d5ec1b55840c9348b9",
            "https://git.kernel.org/stable/c/c72b7a474d3f445bf0c5bcf8ffed332c78eb28a1",
            "https://git.kernel.org/stable/c/e5536677da803ed54a29a446515c28dce7d3d574",
            "https://git.kernel.org/stable/c/e5e06455760f2995b16a176033909347929d1128"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58070",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: bpf_local_storage: Always use bpf_mem_alloc in PREEMPT_RT\n\nIn PREEMPT_RT, kmalloc(GFP_ATOMIC) is still not safe in non preemptible\ncontext. bpf_mem_alloc must be used in PREEMPT_RT. This patch is\nto enforce bpf_mem_alloc in the bpf_local_storage when CONFIG_PREEMPT_RT\nis enabled.\n\n[   35.118559] BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48\n[   35.118566] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1832, name: test_progs\n[   35.118569] preempt_count: 1, expected: 0\n[   35.118571] RCU nest depth: 1, expected: 1\n[   35.118577] INFO: lockdep is turned off.\n    ...\n[   35.118647]  __might_resched+0x433/0x5b0\n[   35.118677]  rt_spin_lock+0xc3/0x290\n[   35.118700]  ___slab_alloc+0x72/0xc40\n[   35.118723]  __kmalloc_noprof+0x13f/0x4e0\n[   35.118732]  bpf_map_kzalloc+0xe5/0x220\n[   35.118740]  bpf_selem_alloc+0x1d2/0x7b0\n[   35.118755]  bpf_local_storage_update+0x2fa/0x8b0\n[   35.118784]  bpf_sk_storage_get_tracing+0x15a/0x1d0\n[   35.118791]  bpf_prog_9a118d86fca78ebb_trace_inet_sock_set_state+0x44/0x66\n[   35.118795]  bpf_trace_run3+0x222/0x400\n[   35.118820]  __bpf_trace_inet_sock_set_state+0x11/0x20\n[   35.118824]  trace_inet_sock_set_state+0x112/0x130\n[   35.118830]  inet_sk_state_store+0x41/0x90\n[   35.118836]  tcp_set_state+0x3b3/0x640\n\nThere is no need to adjust the gfp_flags passing to the\nbpf_mem_cache_alloc_flags() which only honors the GFP_KERNEL.\nThe verifier has ensured GFP_KERNEL is passed only in sleepable context.\n\nIt has been an old issue since the first introduction of the\nbpf_local_storage ~5 years ago, so this patch targets the bpf-next.\n\nbpf_mem_alloc is needed to solve it, so the Fixes tag is set\nto the commit when bpf_mem_alloc was first used in the bpf_local_storage.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/3392fa605d7c5708c5fbe02e4fbdac547c3b7352",
            "https://git.kernel.org/stable/c/8eef6ac4d70eb1f0099fff93321d90ce8fa49ee1",
            "https://git.kernel.org/stable/c/b0027500000dfcb8ee952557d565064cea22c43e",
            "https://git.kernel.org/stable/c/c1d398a3af7e59d7fef351c84fed7ebb575d1f1a"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58071",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nteam: prevent adding a device which is already a team device lower\n\nPrevent adding a device which is already a team device lower,\ne.g. adding veth0 if vlan1 was already added and veth0 is a lower of\nvlan1.\n\nThis is not useful in practice and can lead to recursive locking:\n\n$ ip link add veth0 type veth peer name veth1\n$ ip link set veth0 up\n$ ip link set veth1 up\n$ ip link add link veth0 name veth0.1 type vlan protocol 802.1Q id 1\n$ ip link add team0 type team\n$ ip link set veth0.1 down\n$ ip link set veth0.1 master team0\nteam0: Port device veth0.1 added\n$ ip link set veth0 down\n$ ip link set veth0 master team0\n\n============================================\nWARNING: possible recursive locking detected\n6.13.0-rc2-virtme-00441-ga14a429069bb #46 Not tainted\n--------------------------------------------\nip/7684 is trying to acquire lock:\nffff888016848e00 (team->team_lock_key){+.+.}-{4:4}, at: team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)\n\nbut task is already holding lock:\nffff888016848e00 (team->team_lock_key){+.+.}-{4:4}, at: team_add_slave (drivers/net/team/team_core.c:1147 drivers/net/team/team_core.c:1977)\n\nother info that might help us debug this:\nPossible unsafe locking scenario:\n\nCPU0\n----\nlock(team->team_lock_key);\nlock(team->team_lock_key);\n\n*** DEADLOCK ***\n\nMay be due to missing lock nesting notation\n\n2 locks held by ip/7684:\n\nstack backtrace:\nCPU: 3 UID: 0 PID: 7684 Comm: ip Not tainted 6.13.0-rc2-virtme-00441-ga14a429069bb #46\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\nCall Trace:\n<TASK>\ndump_stack_lvl (lib/dump_stack.c:122)\nprint_deadlock_bug.cold (kernel/locking/lockdep.c:3040)\n__lock_acquire (kernel/locking/lockdep.c:3893 kernel/locking/lockdep.c:5226)\n? netlink_broadcast_filtered (net/netlink/af_netlink.c:1548)\nlock_acquire.part.0 (kernel/locking/lockdep.c:467 kernel/locking/lockdep.c:5851)\n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)\n? trace_lock_acquire (./include/trace/events/lock.h:24 (discriminator 2))\n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)\n? lock_acquire (kernel/locking/lockdep.c:5822)\n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)\n__mutex_lock (kernel/locking/mutex.c:587 kernel/locking/mutex.c:735)\n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)\n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)\n? fib_sync_up (net/ipv4/fib_semantics.c:2167)\n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)\nteam_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)\nnotifier_call_chain (kernel/notifier.c:85)\ncall_netdevice_notifiers_info (net/core/dev.c:1996)\n__dev_notify_flags (net/core/dev.c:8993)\n? __dev_change_flags (net/core/dev.c:8975)\ndev_change_flags (net/core/dev.c:9027)\nvlan_device_event (net/8021q/vlan.c:85 net/8021q/vlan.c:470)\n? br_device_event (net/bridge/br.c:143)\nnotifier_call_chain (kernel/notifier.c:85)\ncall_netdevice_notifiers_info (net/core/dev.c:1996)\ndev_open (net/core/dev.c:1519 net/core/dev.c:1505)\nteam_add_slave (drivers/net/team/team_core.c:1219 drivers/net/team/team_core.c:1977)\n? __pfx_team_add_slave (drivers/net/team/team_core.c:1972)\ndo_set_master (net/core/rtnetlink.c:2917)\ndo_setlink.isra.0 (net/core/rtnetlink.c:3117)",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/0a7794b9ca78c8e7d001c583bf05736169de3f20",
            "https://git.kernel.org/stable/c/184a564e6000b41582f160a5be9a9b5aabe22ac1",
            "https://git.kernel.org/stable/c/1bb06f919fa5bec77ad9b6002525c3dcc5c1fd6c",
            "https://git.kernel.org/stable/c/3fff5da4ca2164bb4d0f1e6cd33f6eb8a0e73e50",
            "https://git.kernel.org/stable/c/62ff1615815d565448c37cb8a7a2a076492ec471",
            "https://git.kernel.org/stable/c/adff6ac889e16d97abd1e4543f533221127e978a",
            "https://git.kernel.org/stable/c/bd099a2fa9be983ba0e90a57a59484fe9d520ba8",
            "https://git.kernel.org/stable/c/d9bce1310c0e2a55888e3e08c9f69d8377b3a377"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58072",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtlwifi: remove unused check_buddy_priv\n\nCommit 2461c7d60f9f (\"rtlwifi: Update header file\") introduced a global\nlist of private data structures.\n\nLater on, commit 26634c4b1868 (\"rtlwifi Modify existing bits to match\nvendor version 2013.02.07\") started adding the private data to that list at\nprobe time and added a hook, check_buddy_priv to find the private data from\na similar device.\n\nHowever, that function was never used.\n\nBesides, though there is a lock for that list, it is never used. And when\nthe probe fails, the private data is never removed from the list. This\nwould cause a second probe to access freed memory.\n\nRemove the unused hook, structures and members, which will prevent the\npotential race condition on the list and its corruption during a second\nprobe when probe fails.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/006e803af7408c3fc815b0654fc5ab43d34f0154",
            "https://git.kernel.org/stable/c/1b9cbd8a9ae68b32099fbb03b2d5ffa0c5e0dcc9",
            "https://git.kernel.org/stable/c/1e39b0486cdb496cdfba3bc89886150e46acf6f4",
            "https://git.kernel.org/stable/c/2fdac64c3c35858aa8ac5caa70b232e03456e120",
            "https://git.kernel.org/stable/c/465d01ef6962b82b1f0ad1f3e58b398dbd35c1c1",
            "https://git.kernel.org/stable/c/543e3e9f2e9e47ded774c74e680f28a0ca362aee",
            "https://git.kernel.org/stable/c/8e2fcc68fbaab3ad9f5671fee2be0956134b740a",
            "https://git.kernel.org/stable/c/f801e754efa21bd61b3cc15ec7565696165b272f"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58073",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/msm/dpu: check dpu_plane_atomic_print_state() for valid sspp\n\nSimilar to the r_pipe sspp protect, add a check to protect\nthe pipe state prints to avoid NULL ptr dereference for cases when\nthe state is dumped without a corresponding atomic_check() where the\npipe->sspp is assigned.\n\nPatchwork: https://patchwork.freedesktop.org/patch/628404/",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/008af2074e4b91d34440102501b710c235a3b245",
            "https://git.kernel.org/stable/c/789384eb1437aed94155dc0eac8a8a6ba1baf578"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58074",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915: Grab intel_display from the encoder to avoid potential oopsies\n\nGrab the intel_display from 'encoder' rather than 'state'\nin the encoder hooks to avoid the massive footgun that is\nintel_sanitize_encoder(), which passes NULL as the 'state'\nargument to encoder .disable() and .post_disable().\n\nTODO: figure out how to actually fix intel_sanitize_encoder()...",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/1885401569f24eb35c631bcc4e6543360dbe9292",
            "https://git.kernel.org/stable/c/dc3806d9eb66d0105f8d55d462d4ef681d9eac59"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58075",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: tegra - do not transfer req when tegra init fails\n\nThe tegra_cmac_init or tegra_sha_init function may return an error when\nmemory is exhausted. It should not transfer the request when they return\nan error.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/15589bda46830695a3261518bb7627afac61f519",
            "https://git.kernel.org/stable/c/1dbc270f9df7f0ae1e591323431869059cee1b7d",
            "https://git.kernel.org/stable/c/5eaa7c916e1ec4b122a1c3a8a20e692d9d9e174e"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21825",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Cancel the running bpf_timer through kworker for PREEMPT_RT\n\nDuring the update procedure, when overwrite element in a pre-allocated\nhtab, the freeing of old_element is protected by the bucket lock. The\nreason why the bucket lock is necessary is that the old_element has\nalready been stashed in htab->extra_elems after alloc_htab_elem()\nreturns. If freeing the old_element after the bucket lock is unlocked,\nthe stashed element may be reused by concurrent update procedure and the\nfreeing of old_element will run concurrently with the reuse of the\nold_element. However, the invocation of check_and_free_fields() may\nacquire a spin-lock which violates the lockdep rule because its caller\nhas already held a raw-spin-lock (bucket lock). The following warning\nwill be reported when such race happens:\n\n  BUG: scheduling while atomic: test_progs/676/0x00000003\n  3 locks held by test_progs/676:\n  #0: ffffffff864b0240 (rcu_read_lock_trace){....}-{0:0}, at: bpf_prog_test_run_syscall+0x2c0/0x830\n  #1: ffff88810e961188 (&htab->lockdep_key){....}-{2:2}, at: htab_map_update_elem+0x306/0x1500\n  #2: ffff8881f4eac1b8 (&base->softirq_expiry_lock){....}-{2:2}, at: hrtimer_cancel_wait_running+0xe9/0x1b0\n  Modules linked in: bpf_testmod(O)\n  Preemption disabled at:\n  [<ffffffff817837a3>] htab_map_update_elem+0x293/0x1500\n  CPU: 0 UID: 0 PID: 676 Comm: test_progs Tainted: G ... 6.12.0+ #11\n  Tainted: [W]=WARN, [O]=OOT_MODULE\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)...\n  Call Trace:\n  <TASK>\n  dump_stack_lvl+0x57/0x70\n  dump_stack+0x10/0x20\n  __schedule_bug+0x120/0x170\n  __schedule+0x300c/0x4800\n  schedule_rtlock+0x37/0x60\n  rtlock_slowlock_locked+0x6d9/0x54c0\n  rt_spin_lock+0x168/0x230\n  hrtimer_cancel_wait_running+0xe9/0x1b0\n  hrtimer_cancel+0x24/0x30\n  bpf_timer_delete_work+0x1d/0x40\n  bpf_timer_cancel_and_free+0x5e/0x80\n  bpf_obj_free_fields+0x262/0x4a0\n  check_and_free_fields+0x1d0/0x280\n  htab_map_update_elem+0x7fc/0x1500\n  bpf_prog_9f90bc20768e0cb9_overwrite_cb+0x3f/0x43\n  bpf_prog_ea601c4649694dbd_overwrite_timer+0x5d/0x7e\n  bpf_prog_test_run_syscall+0x322/0x830\n  __sys_bpf+0x135d/0x3ca0\n  __x64_sys_bpf+0x75/0xb0\n  x64_sys_call+0x1b5/0xa10\n  do_syscall_64+0x3b/0xc0\n  entry_SYSCALL_64_after_hwframe+0x4b/0x53\n  ...\n  </TASK>\n\nIt seems feasible to break the reuse and refill of per-cpu extra_elems\ninto two independent parts: reuse the per-cpu extra_elems with bucket\nlock being held and refill the old_element as per-cpu extra_elems after\nthe bucket lock is unlocked. However, it will make the concurrent\noverwrite procedures on the same CPU return unexpected -E2BIG error when\nthe map is full.\n\nTherefore, the patch fixes the lock problem by breaking the cancelling\nof bpf_timer into two steps for PREEMPT_RT:\n1) use hrtimer_try_to_cancel() and check its return value\n2) if the timer is running, use hrtimer_cancel() through a kworker to\n   cancel it again\nConsidering that the current implementation of hrtimer_cancel() will try\nto acquire a being held softirq_expiry_lock when the current timer is\nrunning, these steps above are reasonable. However, it also has\ndownside. When the timer is running, the cancelling of the timer is\ndelayed when releasing the last map uref. The delay is also fixable\n(e.g., break the cancelling of bpf timer into two parts: one part in\nlocked scope, another one in unlocked scope), it can be revised later if\nnecessary.\n\nIt is a bit hard to decide the right fix tag. One reason is that the\nproblem depends on PREEMPT_RT which is enabled in v6.12. Considering the\nsoftirq_expiry_lock lock exists since v5.4 and bpf_timer is introduced\nin v5.15, the bpf_timer commit is used in the fixes tag and an extra\ndepends-on tag is added to state the dependency on PREEMPT_RT.\n\nDepends-on: v6.12+ with PREEMPT_RT enabled",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/33e47d9573075342a41783a55c8c67bc71246fc1",
            "https://git.kernel.org/stable/c/58f038e6d209d2dd862fcf5de55407855856794d",
            "https://git.kernel.org/stable/c/fbeda3d939ca10063aafa7a77cc0f409d82cda88"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21826",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: reject mismatching sum of field_len with set key length\n\nThe field length description provides the length of each separated key\nfield in the concatenation, each field gets rounded up to 32-bits to\ncalculate the pipapo rule width from pipapo_init(). The set key length\nprovides the total size of the key aligned to 32-bits.\n\nRegister-based arithmetics still allows for combining mismatching set\nkey length and field length description, eg. set key length 10 and field\ndescription [ 5, 4 ] leading to pipapo width of 12.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/1b9335a8000fb70742f7db10af314104b6ace220",
            "https://git.kernel.org/stable/c/2ac254343d3cf228ae0738b2615fedf85d000752",
            "https://git.kernel.org/stable/c/49b7182b97bafbd5645414aff054b4a65d05823d",
            "https://git.kernel.org/stable/c/5083a7ae45003456c253e981b30a43f71230b4a3",
            "https://git.kernel.org/stable/c/6b467c8feac759f4c5c86d708beca2aa2b29584f",
            "https://git.kernel.org/stable/c/82e491e085719068179ff6a5466b7387cc4bbf32",
            "https://git.kernel.org/stable/c/ab50d0eff4a939d20c37721fd9766347efcdb6f6"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21827",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: btusb: mediatek: Add locks for usb_driver_claim_interface()\n\nThe documentation for usb_driver_claim_interface() says that \"the\ndevice lock\" is needed when the function is called from places other\nthan probe(). This appears to be the lock for the USB interface\ndevice. The Mediatek btusb code gets called via this path:\n\n  Workqueue: hci0 hci_power_on [bluetooth]\n  Call trace:\n   usb_driver_claim_interface\n   btusb_mtk_claim_iso_intf\n   btusb_mtk_setup\n   hci_dev_open_sync\n   hci_power_on\n   process_scheduled_works\n   worker_thread\n   kthread\n\nWith the above call trace the device lock hasn't been claimed. Claim\nit.\n\nWithout this fix, we'd sometimes see the error \"Failed to claim iso\ninterface\". Sometimes we'd even see worse errors, like a NULL pointer\ndereference (where `intf->dev.driver` was NULL) with a trace like:\n\n  Call trace:\n   usb_suspend_both\n   usb_runtime_suspend\n   __rpm_callback\n   rpm_suspend\n   pm_runtime_work\n   process_scheduled_works\n\nBoth errors appear to be fixed with the proper locking.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/4194766ec8756f4f654d595ae49962acbac49490",
            "https://git.kernel.org/stable/c/930e1790b99e5839e1af69d2f7fd808f1fba2df9",
            "https://git.kernel.org/stable/c/e9087e828827e5a5c85e124ce77503f2b81c3491"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21828",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: don't flush non-uploaded STAs\n\nIf STA state is pre-moved to AUTHORIZED (such as in IBSS\nscenarios) and insertion fails, the station is freed.\nIn this case, the driver never knew about the station,\nso trying to flush it is unexpected and may crash.\n\nCheck if the sta was uploaded to the driver before and\nfix this.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/9efb5531271fa7ebae993b2a33a705d9947c7ce6",
            "https://git.kernel.org/stable/c/aa3ce3f8fafa0b8fb062f28024855ea8cb3f3450",
            "https://git.kernel.org/stable/c/cd10b7fcb95a6a86c67adc54304c59a578ab16af",
            "https://git.kernel.org/stable/c/cf21ef3d430847ba864bbc9b2774fffcc03ce321"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58076",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: gcc-sm6350: Add missing parent_map for two clocks\n\nIf a clk_rcg2 has a parent, it should also have parent_map defined,\notherwise we'll get a NULL pointer dereference when calling clk_set_rate\nlike the following:\n\n  [    3.388105] Call trace:\n  [    3.390664]  qcom_find_src_index+0x3c/0x70 (P)\n  [    3.395301]  qcom_find_src_index+0x1c/0x70 (L)\n  [    3.399934]  _freq_tbl_determine_rate+0x48/0x100\n  [    3.404753]  clk_rcg2_determine_rate+0x1c/0x28\n  [    3.409387]  clk_core_determine_round_nolock+0x58/0xe4\n  [    3.421414]  clk_core_round_rate_nolock+0x48/0xfc\n  [    3.432974]  clk_core_round_rate_nolock+0xd0/0xfc\n  [    3.444483]  clk_core_set_rate_nolock+0x8c/0x300\n  [    3.455886]  clk_set_rate+0x38/0x14c\n\nAdd the parent_map property for two clocks where it's missing and also\nun-inline the parent_data as well to keep the matching parent_map and\nparent_data together.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/08b77ed7cfaac62bba51ac7a0487409ec9fcbc84",
            "https://git.kernel.org/stable/c/175af15551ed5aa6af16ff97aff75cfffb42da21",
            "https://git.kernel.org/stable/c/39336edd14a59dc086fb19957655e0f340bb28e8",
            "https://git.kernel.org/stable/c/3e567032233a240b903dc11c9f18eeb3faa10ffa",
            "https://git.kernel.org/stable/c/96fe1a7ee477d701cfc98ab9d3c730c35d966861",
            "https://git.kernel.org/stable/c/b6fe13566bf5676b1e3b72d2a06d875733e93ee6"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58077",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: soc-pcm: don't use soc_pcm_ret() on .prepare callback\n\ncommit 1f5664351410 (\"ASoC: lower \"no backend DAIs enabled for ... Port\"\nlog severity\") ignores -EINVAL error message on common soc_pcm_ret().\nIt is used from many functions, ignoring -EINVAL is over-kill.\n\nThe reason why -EINVAL was ignored was it really should only be used\nupon invalid parameters coming from userspace and in that case we don't\nwant to log an error since we do not want to give userspace a way to do\na denial-of-service attack on the syslog / diskspace.\n\nSo don't use soc_pcm_ret() on .prepare callback is better idea.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/301c26a018acb94dd537a4418cefa0f654500c6f",
            "https://git.kernel.org/stable/c/79b8c7c93beb4f5882c9ee5b9ba73354fa4bc9ee",
            "https://git.kernel.org/stable/c/8ec4e8c8e142933eaa8e1ed87168831069250e4e",
            "https://git.kernel.org/stable/c/90778f31efdf44622065ebbe8d228284104bd26f",
            "https://git.kernel.org/stable/c/b65ba768302adc7ddc70811116cef80ca089af59"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58078",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: misc_minor_alloc to use ida for all dynamic/misc dynamic minors\n\nmisc_minor_alloc was allocating id using ida for minor only in case of\nMISC_DYNAMIC_MINOR but misc_minor_free was always freeing ids\nusing ida_free causing a mismatch and following warn:\n> > WARNING: CPU: 0 PID: 159 at lib/idr.c:525 ida_free+0x3e0/0x41f\n> > ida_free called for id=127 which is not allocated.\n> > <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n...\n> > [<60941eb4>] ida_free+0x3e0/0x41f\n> > [<605ac993>] misc_minor_free+0x3e/0xbc\n> > [<605acb82>] misc_deregister+0x171/0x1b3\n\nmisc_minor_alloc is changed to allocate id from ida for all minors\nfalling in the range of dynamic/ misc dynamic minors",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/3df72111c39f7e4c5029c9ff720b56ec2e05b764",
            "https://git.kernel.org/stable/c/6635332d246d7db89b90e145f2bf937406cecaf0",
            "https://git.kernel.org/stable/c/6d04d2b554b14ae6c428a9c60b6c85f1e5c89f68",
            "https://git.kernel.org/stable/c/8b4120b3e060e137eaa8dc76a1c40401088336e5"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58079",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: uvcvideo: Fix crash during unbind if gpio unit is in use\n\nWe used the wrong device for the device managed functions. We used the\nusb device, when we should be using the interface device.\n\nIf we unbind the driver from the usb interface, the cleanup functions\nare never called. In our case, the IRQ is never disabled.\n\nIf an IRQ is triggered, it will try to access memory sections that are\nalready free, causing an OOPS.\n\nWe cannot use the function devm_request_threaded_irq here. The devm_*\nclean functions may be called after the main structure is released by\nuvc_delete.\n\nLuckily this bug has small impact, as it is only affected by devices\nwith gpio units and the user has to unbind the device, a disconnect will\nnot trigger this error.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/0b5e0445bc8384c18bd35cb9fe87f6258c6271d9",
            "https://git.kernel.org/stable/c/0fdd7cc593385e46e92e180b71e264fc9c195298",
            "https://git.kernel.org/stable/c/3c00e94d00ca079bef7906d6f39d1091bccfedd3",
            "https://git.kernel.org/stable/c/5d2e65cbe53d0141ed095cf31c2dcf3d8668c11d",
            "https://git.kernel.org/stable/c/a9ea1a3d88b7947ce8cadb2afceee7a54872bbc5",
            "https://git.kernel.org/stable/c/d2eac8b14ac690aa73052aa6d4ba69005715367e"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58080",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: dispcc-sm6350: Add missing parent_map for a clock\n\nIf a clk_rcg2 has a parent, it should also have parent_map defined,\notherwise we'll get a NULL pointer dereference when calling clk_set_rate\nlike the following:\n\n  [    3.388105] Call trace:\n  [    3.390664]  qcom_find_src_index+0x3c/0x70 (P)\n  [    3.395301]  qcom_find_src_index+0x1c/0x70 (L)\n  [    3.399934]  _freq_tbl_determine_rate+0x48/0x100\n  [    3.404753]  clk_rcg2_determine_rate+0x1c/0x28\n  [    3.409387]  clk_core_determine_round_nolock+0x58/0xe4\n  [    3.421414]  clk_core_round_rate_nolock+0x48/0xfc\n  [    3.432974]  clk_core_round_rate_nolock+0xd0/0xfc\n  [    3.444483]  clk_core_set_rate_nolock+0x8c/0x300\n  [    3.455886]  clk_set_rate+0x38/0x14c\n\nAdd the parent_map property for the clock where it's missing and also\nun-inline the parent_data as well to keep the matching parent_map and\nparent_data together.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/2dba8d5d423fa5f6f3a687aa6e0da5808f69091b",
            "https://git.kernel.org/stable/c/3ad28517385e2821e8e43388d6a0b3e1ba0bc3ab",
            "https://git.kernel.org/stable/c/3daca9050857220726732ad9d4a8512069386f46",
            "https://git.kernel.org/stable/c/a1f15808adfd77268eac7fefce5378ad9fedbfba",
            "https://git.kernel.org/stable/c/d4cdb196f182d2fbe336c968228be00d8c3fed05"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58081",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: mmp2: call pm_genpd_init() only after genpd.name is set\n\nSetting the genpd's struct device's name with dev_set_name() is\nhappening within pm_genpd_init(). If it remains NULL, things can blow up\nlater, such as when crafting the devfs hierarchy for the power domain:\n\n  Unable to handle kernel NULL pointer dereference at virtual address 00000000 when read\n  ...\n  Call trace:\n   strlen from start_creating+0x90/0x138\n   start_creating from debugfs_create_dir+0x20/0x178\n   debugfs_create_dir from genpd_debug_add.part.0+0x4c/0x144\n   genpd_debug_add.part.0 from genpd_debug_init+0x74/0x90\n   genpd_debug_init from do_one_initcall+0x5c/0x244\n   do_one_initcall from kernel_init_freeable+0x19c/0x1f4\n   kernel_init_freeable from kernel_init+0x1c/0x12c\n   kernel_init from ret_from_fork+0x14/0x28\n\nBisecting tracks this crash back to commit 899f44531fe6 (\"pmdomain: core:\nAdd GENPD_FLAG_DEV_NAME_FW flag\"), which exchanges use of genpd->name\nwith dev_name(&genpd->dev) in genpd_debug_add.part().",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/763517124e27b07fa300b486d7d13c5d563a215e",
            "https://git.kernel.org/stable/c/e24b15d4704dcb73920c3d18a6157abd18df08c1",
            "https://git.kernel.org/stable/c/eca01d5911fb34218d10a58d8d9534b758c8fd0a"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58082",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: nuvoton: Fix an error check in npcm_video_ece_init()\n\nWhen function of_find_device_by_node() fails, it returns NULL instead of\nan error code. So the corresponding error check logic should be modified\nto check whether the return value is NULL and set the error code to be\nreturned as -ENODEV.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/bdd823b9d068284e1d998b962cfef29236365df3",
            "https://git.kernel.org/stable/c/c36b830754ae1dd1db41c27f57b29267878f9702",
            "https://git.kernel.org/stable/c/c4b7779abc6633677e6edb79e2809f4f61fde157"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58083",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: Explicitly verify target vCPU is online in kvm_get_vcpu()\n\nExplicitly verify the target vCPU is fully online _prior_ to clamping the\nindex in kvm_get_vcpu().  If the index is \"bad\", the nospec clamping will\ngenerate '0', i.e. KVM will return vCPU0 instead of NULL.\n\nIn practice, the bug is unlikely to cause problems, as it will only come\ninto play if userspace or the guest is buggy or misbehaving, e.g. KVM may\nsend interrupts to vCPU0 instead of dropping them on the floor.\n\nHowever, returning vCPU0 when it shouldn't exist per online_vcpus is\nproblematic now that KVM uses an xarray for the vCPUs array, as KVM needs\nto insert into the xarray before publishing the vCPU to userspace (see\ncommit c5b077549136 (\"KVM: Convert the kvm->vcpus array to a xarray\")),\ni.e. before vCPU creation is guaranteed to succeed.\n\nAs a result, incorrectly providing access to vCPU0 will trigger a\nuse-after-free if vCPU0 is dereferenced and kvm_vm_ioctl_create_vcpu()\nbails out of vCPU creation due to an error and frees vCPU0.  Commit\nafb2acb2e3a3 (\"KVM: Fix vcpu_array[0] races\") papered over that issue, but\nin doing so introduced an unsolvable teardown conundrum.  Preventing\naccesses to vCPU0 before it's fully online will allow reverting commit\nafb2acb2e3a3, without re-introducing the vcpu_array[0] UAF race.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/09d50ccf0b2d739db4a485b08afe7520a4402a63",
            "https://git.kernel.org/stable/c/125da53b3c0c9d7f58353aea0076e9efd6498ba7",
            "https://git.kernel.org/stable/c/1e7381f3617d14b3c11da80ff5f8a93ab14cfc46",
            "https://git.kernel.org/stable/c/5cce2ed69b00e022b5cdf0c49c82986abd2941a8",
            "https://git.kernel.org/stable/c/7c4899239d0f70f88ac42665b3da51678d122480",
            "https://git.kernel.org/stable/c/ca8da90ed1432ff3d000de4f1e2275d4e7d21b96",
            "https://git.kernel.org/stable/c/d817e510662fd1c9797952408d94806f97a5fffd",
            "https://git.kernel.org/stable/c/f2f805ada63b536bc192458a7098388286568ad4"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58084",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirmware: qcom: scm: Fix missing read barrier in qcom_scm_get_tzmem_pool()\n\nCommit 2e4955167ec5 (\"firmware: qcom: scm: Fix __scm and waitq\ncompletion variable initialization\") introduced a write barrier in probe\nfunction to store global '__scm' variable.  We all known barriers are\npaired (see memory-barriers.txt: \"Note that write barriers should\nnormally be paired with read or address-dependency barriers\"), therefore\naccessing it from concurrent contexts requires read barrier.  Previous\ncommit added such barrier in qcom_scm_is_available(), so let's use that\ndirectly.\n\nLack of this read barrier can result in fetching stale '__scm' variable\nvalue, NULL, and dereferencing it.\n\nNote that barrier in qcom_scm_is_available() satisfies here the control\ndependency.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/b628510397b5cafa1f5d3e848a28affd1c635302",
            "https://git.kernel.org/stable/c/e03db7c1255ebabba5e1a447754faeb138de15a2",
            "https://git.kernel.org/stable/c/fee921e3c641f64185abee83f9a6e65f0b380682"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58085",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntomoyo: don't emit warning in tomoyo_write_control()\n\nsyzbot is reporting too large allocation warning at tomoyo_write_control(),\nfor one can write a very very long line without new line character. To fix\nthis warning, I use __GFP_NOWARN rather than checking for KMALLOC_MAX_SIZE,\nfor practically a valid line should be always shorter than 32KB where the\n\"too small to fail\" memory-allocation rule applies.\n\nOne might try to write a valid line that is longer than 32KB, but such\nrequest will likely fail with -ENOMEM. Therefore, I feel that separately\nreturning -EINVAL when a line is longer than KMALLOC_MAX_SIZE is redundant.\nThere is no need to distinguish over-32KB and over-KMALLOC_MAX_SIZE.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/3df7546fc03b8f004eee0b9e3256369f7d096685",
            "https://git.kernel.org/stable/c/414705c0303350d139b1dc18f329fe47dfb642dd",
            "https://git.kernel.org/stable/c/a01c200fa7eb59da4d2dbbb48b61f4a0d196c09f",
            "https://git.kernel.org/stable/c/b2bd5857a0d6973ebbcb4d9831ddcaebbd257be1",
            "https://git.kernel.org/stable/c/c67efabddc73171c7771d3ffe4ffa1e503ee533e",
            "https://git.kernel.org/stable/c/c9382f380e8d09209b8e5c0def0545852168be25",
            "https://git.kernel.org/stable/c/f6b37b3e12de638753bce79a2858070b9c4a4ad3",
            "https://git.kernel.org/stable/c/fe1c021eb03dae0dc9dce55e81f77a60e419a27a"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2024-58086",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/v3d: Stop active perfmon if it is being destroyed\n\nIf the active performance monitor (`v3d->active_perfmon`) is being\ndestroyed, stop it first. Currently, the active perfmon is not\nstopped during destruction, leaving the `v3d->active_perfmon` pointer\nstale. This can lead to undefined behavior and instability.\n\nThis patch ensures that the active perfmon is stopped before being\ndestroyed, aligning with the behavior introduced in commit\n7d1fd3638ee3 (\"drm/v3d: Stop the active perfmon before being destroyed\").",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/1c5673a2c8926adbb61f340c779b28e18188a8cd",
            "https://git.kernel.org/stable/c/21f1435b1e6b012a07c42f36b206d2b66fc8f13b",
            "https://git.kernel.org/stable/c/22e19c8c5f6b709f4ae40227392a30d57bac187d",
            "https://git.kernel.org/stable/c/95036d4c01167568166108d42c2b0e9f8dbd7d2b",
            "https://git.kernel.org/stable/c/eb0e0eca0eab93f310c6c37b8564049366704691",
            "https://git.kernel.org/stable/c/f8805b12f477bd964e2820a87921c7b58cc2dee3"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21829",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/rxe: Fix the warning \"__rxe_cleanup+0x12c/0x170 [rdma_rxe]\"\n\nThe Call Trace is as below:\n\"\n  <TASK>\n  ? show_regs.cold+0x1a/0x1f\n  ? __rxe_cleanup+0x12c/0x170 [rdma_rxe]\n  ? __warn+0x84/0xd0\n  ? __rxe_cleanup+0x12c/0x170 [rdma_rxe]\n  ? report_bug+0x105/0x180\n  ? handle_bug+0x46/0x80\n  ? exc_invalid_op+0x19/0x70\n  ? asm_exc_invalid_op+0x1b/0x20\n  ? __rxe_cleanup+0x12c/0x170 [rdma_rxe]\n  ? __rxe_cleanup+0x124/0x170 [rdma_rxe]\n  rxe_destroy_qp.cold+0x24/0x29 [rdma_rxe]\n  ib_destroy_qp_user+0x118/0x190 [ib_core]\n  rdma_destroy_qp.cold+0x43/0x5e [rdma_cm]\n  rtrs_cq_qp_destroy.cold+0x1d/0x2b [rtrs_core]\n  rtrs_srv_close_work.cold+0x1b/0x31 [rtrs_server]\n  process_one_work+0x21d/0x3f0\n  worker_thread+0x4a/0x3c0\n  ? process_one_work+0x3f0/0x3f0\n  kthread+0xf0/0x120\n  ? kthread_complete_and_exit+0x20/0x20\n  ret_from_fork+0x22/0x30\n  </TASK>\n\"\nWhen too many rdma resources are allocated, rxe needs more time to\nhandle these rdma resources. Sometimes with the current timeout, rxe\ncan not release the rdma resources correctly.\n\nCompared with other rdma drivers, a bigger timeout is used.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/45e567800492088bc52c9abac35524b4d332a8f8",
            "https://git.kernel.org/stable/c/720653309dd31c8a927ef5d87964578ad544980f",
            "https://git.kernel.org/stable/c/7a2de8126ed3801f2396720e10a03cd546a3cea1",
            "https://git.kernel.org/stable/c/a7d15eaecf0d6e13226db629ae2401c8c02683e5",
            "https://git.kernel.org/stable/c/edc4ef0e0154096d6c0cf5e06af6fc330dbad9d1"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21830",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlandlock: Handle weird files\n\nA corrupted filesystem (e.g. bcachefs) might return weird files.\nInstead of throwing a warning and allowing access to such file, treat\nthem as regular files.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/0fde195a373ab1267e60baa9e1a703a97e7464cd",
            "https://git.kernel.org/stable/c/2569e65d2eb6ac1afe6cb6dfae476afee8b6771a",
            "https://git.kernel.org/stable/c/39bb3d56f1c351e76bb18895d0e73796e653d5c1",
            "https://git.kernel.org/stable/c/49440290a0935f428a1e43a5ac8dc275a647ff80",
            "https://git.kernel.org/stable/c/7d6121228959ddf44a4b9b6a177384ac7854e2f9",
            "https://git.kernel.org/stable/c/a1fccf6b72b56343dd4f2d96b008147f9951eebd"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21831",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: Avoid putting some root ports into D3 on TUXEDO Sirius Gen1\n\ncommit 9d26d3a8f1b0 (\"PCI: Put PCIe ports into D3 during suspend\") sets the\npolicy that all PCIe ports are allowed to use D3.  When the system is\nsuspended if the port is not power manageable by the platform and won't be\nused for wakeup via a PME this sets up the policy for these ports to go\ninto D3hot.\n\nThis policy generally makes sense from an OSPM perspective but it leads to\nproblems with wakeup from suspend on the TUXEDO Sirius 16 Gen 1 with a\nspecific old BIOS. This manifests as a system hang.\n\nOn the affected Device + BIOS combination, add a quirk for the root port of\nthe problematic controller to ensure that these root ports are not put into\nD3hot at suspend.\n\nThis patch is based on\n\n  https://lore.kernel.org/linux-pci/20230708214457.1229-2-mario.limonciello@amd.com\n\nbut with the added condition both in the documentation and in the code to\napply only to the TUXEDO Sirius 16 Gen 1 with a specific old BIOS and only\nthe affected root ports.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/5ee3dd6e59b834e4d66e8b16fc684749ee40a257",
            "https://git.kernel.org/stable/c/8852e056e297df1d8635ee7504e780d3184e45d0",
            "https://git.kernel.org/stable/c/a78dfe50fffe6058afed2bb04c50c2c9a16664ee",
            "https://git.kernel.org/stable/c/b1049f2d68693c80a576c4578d96774a68df2bad"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21832",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock: don't revert iter for -EIOCBQUEUED\n\nblkdev_read_iter() has a few odd checks, like gating the position and\ncount adjustment on whether or not the result is bigger-than-or-equal to\nzero (where bigger than makes more sense), and not checking the return\nvalue of blkdev_direct_IO() before doing an iov_iter_revert(). The\nlatter can lead to attempting to revert with a negative value, which\nwhen passed to iov_iter_revert() as an unsigned value will lead to\nthrowing a WARN_ON() because unroll is bigger than MAX_RW_COUNT.\n\nBe sane and don't revert for -EIOCBQUEUED, like what is done in other\nspots.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/68f16d3034a06661245ecd22f0d586a8b4e7c473",
            "https://git.kernel.org/stable/c/6c26619effb1b4cb7d20b4e666ab8f71f6a53ccb",
            "https://git.kernel.org/stable/c/84671b0630ccb46ae9f1f99a45c7d63ffcd6a474",
            "https://git.kernel.org/stable/c/a58f136bad29f9ae721a29d98c042fddbee22f77",
            "https://git.kernel.org/stable/c/b13ee668e8280ca5b07f8ce2846b9957a8a10853"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21833",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/vt-d: Avoid use of NULL after WARN_ON_ONCE\n\nThere is a WARN_ON_ONCE to catch an unlikely situation when\ndomain_remove_dev_pasid can't find the `pasid`. In case it nevertheless\nhappens we must avoid using a NULL pointer.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/60f030f7418d3f1d94f2fb207fe3080e1844630b",
            "https://git.kernel.org/stable/c/df96876be3b064aefc493f760e0639765d13ed0d"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21834",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nseccomp: passthrough uretprobe systemcall without filtering\n\nWhen attaching uretprobes to processes running inside docker, the attached\nprocess is segfaulted when encountering the retprobe.\n\nThe reason is that now that uretprobe is a system call the default seccomp\nfilters in docker block it as they only allow a specific set of known\nsyscalls. This is true for other userspace applications which use seccomp\nto control their syscall surface.\n\nSince uretprobe is a \"kernel implementation detail\" system call which is\nnot used by userspace application code directly, it is impractical and\nthere's very little point in forcing all userspace applications to\nexplicitly allow it in order to avoid crashing tracked processes.\n\nPass this systemcall through seccomp without depending on configuration.\n\nNote: uretprobe is currently only x86_64 and isn't expected to ever be\nsupported in i386.\n\n[kees: minimized changes for easier backporting, tweaked commit log]",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/5a262628f4cf2437d863fe41f9d427177b87664c",
            "https://git.kernel.org/stable/c/cf6cb56ef24410fb5308f9655087f1eddf4452e6",
            "https://git.kernel.org/stable/c/fa80018aa5be10c35e9fa896b7b4061a8dce3eed"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21835",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: f_midi: fix MIDI Streaming descriptor lengths\n\nWhile the MIDI jacks are configured correctly, and the MIDIStreaming\nendpoint descriptors are filled with the correct information,\nbNumEmbMIDIJack and bLength are set incorrectly in these descriptors.\n\nThis does not matter when the numbers of in and out ports are equal, but\nwhen they differ the host will receive broken descriptors with\nuninitialized stack memory leaking into the descriptor for whichever\nvalue is smaller.\n\nThe precise meaning of \"in\" and \"out\" in the port counts is not clearly\ndefined and can be confusing.  But elsewhere the driver consistently\nuses this to match the USB meaning of IN and OUT viewed from the host,\nso that \"in\" ports send data to the host and \"out\" ports receive data\nfrom it.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/3a983390d14e8498f303fc5cb23ab7d696b815db",
            "https://git.kernel.org/stable/c/6ae6dee9f005a2f3b739b85abb6f14a0935699e0",
            "https://git.kernel.org/stable/c/6b16761a928796e4b49e89a0b1ac284155172726",
            "https://git.kernel.org/stable/c/9f36a89dcb78cb7e37f487b04a16396ac18c0636",
            "https://git.kernel.org/stable/c/9f6860a9c11301b052225ca8825f8d2b1a5825bf",
            "https://git.kernel.org/stable/c/a2d0694e1f111379c1efdf439dadd3cfd959fe9d",
            "https://git.kernel.org/stable/c/d8e86700c8a8cf415e300a0921acd6a8f9b494f8",
            "https://git.kernel.org/stable/c/da1668997052ed1cb00322e1f3b63702615c9429"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21836",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring/kbuf: reallocate buf lists on upgrade\n\nIORING_REGISTER_PBUF_RING can reuse an old struct io_buffer_list if it\nwas created for legacy selected buffer and has been emptied. It violates\nthe requirement that most of the field should stay stable after publish.\nAlways reallocate it instead.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/146a185f6c05ee263db715f860620606303c4633",
            "https://git.kernel.org/stable/c/2a5febbef40ce968e295a7aeaa5d5cbd9e3e5ad4",
            "https://git.kernel.org/stable/c/7d0dc28dae836caf7645fef62a10befc624dd17b",
            "https://git.kernel.org/stable/c/8802766324e1f5d414a81ac43365c20142e85603"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21837",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring/uring_cmd: unconditionally copy SQEs at prep time\n\nThis isn't generally necessary, but conditions have been observed where\nSQE data is accessed from the original SQE after prep has been done and\noutside of the initial issue. Opcode prep handlers must ensure that any\nSQE related data is stable beyond the prep phase, but uring_cmd is a bit\nspecial in how it handles the SQE which makes it susceptible to reading\nstale data. If the application has reused the SQE before the original\ncompletes, then that can lead to data corruption.\n\nDown the line we can relax this again once uring_cmd has been sanitized\na bit, and avoid unnecessarily copying the SQE.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/87fe1d68842a308998b315c8ed0163a1d639017c",
            "https://git.kernel.org/stable/c/d6211ebbdaa541af197b50b8dd8f22642ce0b87f"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21838",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: core: flush gadget workqueue after device removal\n\ndevice_del() can lead to new work being scheduled in gadget->work\nworkqueue. This is observed, for example, with the dwc3 driver with the\nfollowing call stack:\n  device_del()\n    gadget_unbind_driver()\n      usb_gadget_disconnect_locked()\n        dwc3_gadget_pullup()\n\t  dwc3_gadget_soft_disconnect()\n\t    usb_gadget_set_state()\n\t      schedule_work(&gadget->work)\n\nMove flush_work() after device_del() to ensure the workqueue is cleaned\nup.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/399a45e5237ca14037120b1b895bd38a3b4492ea",
            "https://git.kernel.org/stable/c/859cb45aefa6de823b2fa7f229fe6d9562c9f3b7",
            "https://git.kernel.org/stable/c/97695b5a1b5467a4f91194db12160f56da445dfe",
            "https://git.kernel.org/stable/c/e3bc1a9a67ce33a2e761e6e7b7c2afc6cb9b7266",
            "https://git.kernel.org/stable/c/f894448f3904d7ad66fecef8f01fe0172629e091"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21839",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Load DR6 with guest value only before entering .vcpu_run() loop\n\nMove the conditional loading of hardware DR6 with the guest's DR6 value\nout of the core .vcpu_run() loop to fix a bug where KVM can load hardware\nwith a stale vcpu->arch.dr6.\n\nWhen the guest accesses a DR and host userspace isn't debugging the guest,\nKVM disables DR interception and loads the guest's values into hardware on\nVM-Enter and saves them on VM-Exit.  This allows the guest to access DRs\nat will, e.g. so that a sequence of DR accesses to configure a breakpoint\nonly generates one VM-Exit.\n\nFor DR0-DR3, the logic/behavior is identical between VMX and SVM, and also\nidentical between KVM_DEBUGREG_BP_ENABLED (userspace debugging the guest)\nand KVM_DEBUGREG_WONT_EXIT (guest using DRs), and so KVM handles loading\nDR0-DR3 in common code, _outside_ of the core kvm_x86_ops.vcpu_run() loop.\n\nBut for DR6, the guest's value doesn't need to be loaded into hardware for\nKVM_DEBUGREG_BP_ENABLED, and SVM provides a dedicated VMCB field whereas\nVMX requires software to manually load the guest value, and so loading the\nguest's value into DR6 is handled by {svm,vmx}_vcpu_run(), i.e. is done\n_inside_ the core run loop.\n\nUnfortunately, saving the guest values on VM-Exit is initiated by common\nx86, again outside of the core run loop.  If the guest modifies DR6 (in\nhardware, when DR interception is disabled), and then the next VM-Exit is\na fastpath VM-Exit, KVM will reload hardware DR6 with vcpu->arch.dr6 and\nclobber the guest's actual value.\n\nThe bug shows up primarily with nested VMX because KVM handles the VMX\npreemption timer in the fastpath, and the window between hardware DR6\nbeing modified (in guest context) and DR6 being read by guest software is\norders of magnitude larger in a nested setup.  E.g. in non-nested, the\nVMX preemption timer would need to fire precisely between #DB injection\nand the #DB handler's read of DR6, whereas with a KVM-on-KVM setup, the\nwindow where hardware DR6 is \"dirty\" extends all the way from L1 writing\nDR6 to VMRESUME (in L1).\n\n    L1's view:\n    ==========\n    <L1 disables DR interception>\n           CPU 0/KVM-7289    [023] d....  2925.640961: kvm_entry: vcpu 0\n A:  L1 Writes DR6\n           CPU 0/KVM-7289    [023] d....  2925.640963: <hack>: Set DRs, DR6 = 0xffff0ff1\n\n B:        CPU 0/KVM-7289    [023] d....  2925.640967: kvm_exit: vcpu 0 reason EXTERNAL_INTERRUPT intr_info 0x800000ec\n\n D: L1 reads DR6, arch.dr6 = 0\n           CPU 0/KVM-7289    [023] d....  2925.640969: <hack>: Sync DRs, DR6 = 0xffff0ff0\n\n           CPU 0/KVM-7289    [023] d....  2925.640976: kvm_entry: vcpu 0\n    L2 reads DR6, L1 disables DR interception\n           CPU 0/KVM-7289    [023] d....  2925.640980: kvm_exit: vcpu 0 reason DR_ACCESS info1 0x0000000000000216\n           CPU 0/KVM-7289    [023] d....  2925.640983: kvm_entry: vcpu 0\n\n           CPU 0/KVM-7289    [023] d....  2925.640983: <hack>: Set DRs, DR6 = 0xffff0ff0\n\n    L2 detects failure\n           CPU 0/KVM-7289    [023] d....  2925.640987: kvm_exit: vcpu 0 reason HLT\n    L1 reads DR6 (confirms failure)\n           CPU 0/KVM-7289    [023] d....  2925.640990: <hack>: Sync DRs, DR6 = 0xffff0ff0\n\n    L0's view:\n    ==========\n    L2 reads DR6, arch.dr6 = 0\n          CPU 23/KVM-5046    [001] d....  3410.005610: kvm_exit: vcpu 23 reason DR_ACCESS info1 0x0000000000000216\n          CPU 23/KVM-5046    [001] .....  3410.005610: kvm_nested_vmexit: vcpu 23 reason DR_ACCESS info1 0x0000000000000216\n\n    L2 => L1 nested VM-Exit\n          CPU 23/KVM-5046    [001] .....  3410.005610: kvm_nested_vmexit_inject: reason: DR_ACCESS ext_inf1: 0x0000000000000216\n\n          CPU 23/KVM-5046    [001] d....  3410.005610: kvm_entry: vcpu 23\n          CPU 23/KVM-5046    [001] d....  3410.005611: kvm_exit: vcpu 23 reason VMREAD\n          CPU 23/KVM-5046    [001] d....  3410.005611: kvm_entry: vcpu 23\n          CPU 23/KVM-5046    [001] d....  3410.\n---truncated---",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/4eb063de686bfcdfd03a8c801d1bbe87d2d5eb55",
            "https://git.kernel.org/stable/c/c2fee09fc167c74a64adb08656cb993ea475197e",
            "https://git.kernel.org/stable/c/d456de38d9eb753a4e9fde053c18d4ef8e485339"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21840",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nthermal/netlink: Prevent userspace segmentation fault by adjusting UAPI header\n\nThe intel-lpmd tool [1], which uses the THERMAL_GENL_ATTR_CPU_CAPABILITY\nattribute to receive HFI events from kernel space, encounters a\nsegmentation fault after commit 1773572863c4 (\"thermal: netlink: Add the\ncommands and the events for the thresholds\").\n\nThe issue arises because the THERMAL_GENL_ATTR_CPU_CAPABILITY raw value\nwas changed while intel_lpmd still uses the old value.\n\nAlthough intel_lpmd can be updated to check the THERMAL_GENL_VERSION and\nuse the appropriate THERMAL_GENL_ATTR_CPU_CAPABILITY value, the commit\nitself is questionable.\n\nThe commit introduced a new element in the middle of enum thermal_genl_attr,\nwhich affects many existing attributes and introduces potential risks\nand unnecessary maintenance burdens for userspace thermal netlink event\nusers.\n\nSolve the issue by moving the newly introduced\nTHERMAL_GENL_ATTR_TZ_PREV_TEMP attribute to the end of the\nenum thermal_genl_attr. This ensures that all existing thermal generic\nnetlink attributes remain unaffected.\n\n[ rjw: Subject edits ]",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/3a4ca365c51729143a2cab693cd40fe0bb585ef0",
            "https://git.kernel.org/stable/c/c195b9c6ab9c383d7aa3f4a65879b3ca90cb378b"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21841",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq/amd-pstate: Fix cpufreq_policy ref counting\n\namd_pstate_update_limits() takes a cpufreq_policy reference but doesn't\ndecrement the refcount in one of the exit paths, fix that.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/28e4c515cf644c621800bd97841757fd49891ba4",
            "https://git.kernel.org/stable/c/3ace20038e19f23fe73259513f1f08d4bf1a3c83",
            "https://git.kernel.org/stable/c/56e6976793c0fcf1638aa534242408ab4e4ca705"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21842",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\namdkfd: properly free gang_ctx_bo when failed to init user queue\n\nThe destructor of a gtt bo is declared as\nvoid amdgpu_amdkfd_free_gtt_mem(struct amdgpu_device *adev, void **mem_obj);\nWhich takes void** as the second parameter.\n\nGCC allows passing void* to the function because void* can be implicitly\ncasted to any other types, so it can pass compiling.\n\nHowever, passing this void* parameter into the function's\nexecution process(which expects void** and dereferencing void**)\nwill result in errors.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/091a68c58c1bbd2ab7d05d1b32c1306394ec691d",
            "https://git.kernel.org/stable/c/a33f7f9660705fb2ecf3467b2c48965564f392ce",
            "https://git.kernel.org/stable/c/ae5ab1c1ae504f622cc1ff48830a9ed48428146d"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    },
    {
        "CVE ID": "CVE-2025-21843",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/panthor: avoid garbage value in panthor_ioctl_dev_query()\n\n'priorities_info' is uninitialized, and the uninitialized value is copied\nto user object when calling PANTHOR_UOBJ_SET(). Using memset to initialize\n'priorities_info' to avoid this garbage value problem.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/3b32b7f638fe61e9d29290960172f4e360e38233",
            "https://git.kernel.org/stable/c/64b95bbc08bacf3e4b05c8604e6a4fec43bb712a"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2024-58087",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: fix racy issue from session lookup and expire\n\nIncrement the session reference count within the lock for lookup to avoid\nracy issue with session expire.",
        "Severity": "HIGH",
        "Patches": [
            "https://git.kernel.org/stable/c/2107ab40629aeabbec369cf34b8cf0f288c3eb1b",
            "https://git.kernel.org/stable/c/37a0e2b362b3150317fb6e2139de67b1e29ae5ff",
            "https://git.kernel.org/stable/c/450a844c045ff0895d41b05a1cbe8febd1acfcfd",
            "https://git.kernel.org/stable/c/a39e31e22a535d47b14656a7d6a893c7f6cf758c",
            "https://git.kernel.org/stable/c/b95629435b84b9ecc0c765995204a4d8a913ed52"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.13:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.13:rc2:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2024-58088",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix deadlock when freeing cgroup storage\n\nThe following commit\nbc235cdb423a (\"bpf: Prevent deadlock from recursive bpf_task_storage_[get|delete]\")\nfirst introduced deadlock prevention for fentry/fexit programs attaching\non bpf_task_storage helpers. That commit also employed the logic in map\nfree path in its v6 version.\n\nLater bpf_cgrp_storage was first introduced in\nc4bcfb38a95e (\"bpf: Implement cgroup storage available to non-cgroup-attached bpf progs\")\nwhich faces the same issue as bpf_task_storage, instead of its busy\ncounter, NULL was passed to bpf_local_storage_map_free() which opened\na window to cause deadlock:\n\n\t<TASK>\n\t\t(acquiring local_storage->lock)\n\t_raw_spin_lock_irqsave+0x3d/0x50\n\tbpf_local_storage_update+0xd1/0x460\n\tbpf_cgrp_storage_get+0x109/0x130\n\tbpf_prog_a4d4a370ba857314_cgrp_ptr+0x139/0x170\n\t? __bpf_prog_enter_recur+0x16/0x80\n\tbpf_trampoline_6442485186+0x43/0xa4\n\tcgroup_storage_ptr+0x9/0x20\n\t\t(holding local_storage->lock)\n\tbpf_selem_unlink_storage_nolock.constprop.0+0x135/0x160\n\tbpf_selem_unlink_storage+0x6f/0x110\n\tbpf_local_storage_map_free+0xa2/0x110\n\tbpf_map_free_deferred+0x5b/0x90\n\tprocess_one_work+0x17c/0x390\n\tworker_thread+0x251/0x360\n\tkthread+0xd2/0x100\n\tret_from_fork+0x34/0x50\n\tret_from_fork_asm+0x1a/0x30\n\t</TASK>\n\nProgs:\n - A: SEC(\"fentry/cgroup_storage_ptr\")\n   - cgid (BPF_MAP_TYPE_HASH)\n\tRecord the id of the cgroup the current task belonging\n\tto in this hash map, using the address of the cgroup\n\tas the map key.\n   - cgrpa (BPF_MAP_TYPE_CGRP_STORAGE)\n\tIf current task is a kworker, lookup the above hash\n\tmap using function parameter @owner as the key to get\n\tits corresponding cgroup id which is then used to get\n\ta trusted pointer to the cgroup through\n\tbpf_cgroup_from_id(). This trusted pointer can then\n\tbe passed to bpf_cgrp_storage_get() to finally trigger\n\tthe deadlock issue.\n - B: SEC(\"tp_btf/sys_enter\")\n   - cgrpb (BPF_MAP_TYPE_CGRP_STORAGE)\n\tThe only purpose of this prog is to fill Prog A's\n\thash map by calling bpf_cgrp_storage_get() for as\n\tmany userspace tasks as possible.\n\nSteps to reproduce:\n - Run A;\n - while (true) { Run B; Destroy B; }\n\nFix this issue by passing its busy counter to the free procedure so\nit can be properly incremented before storage/smap locking.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/6ecb9fa14eec5f15d97c84c36896871335f6ddfb",
            "https://git.kernel.org/stable/c/c78f4afbd962f43a3989f45f3ca04300252b19b5",
            "https://git.kernel.org/stable/c/fac674d2bd68f3479f27328626b42d1eebd11fef",
            "https://git.kernel.org/stable/c/fcec95b4ab3e7bc6b2f36e5d59f7e24104ea87f7"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2024-58089",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix double accounting race when btrfs_run_delalloc_range() failed\n\n[BUG]\nWhen running btrfs with block size (4K) smaller than page size (64K,\naarch64), there is a very high chance to crash the kernel at\ngeneric/750, with the following messages:\n(before the call traces, there are 3 extra debug messages added)\n\n  BTRFS warning (device dm-3): read-write for sector size 4096 with page size 65536 is experimental\n  BTRFS info (device dm-3): checking UUID tree\n  hrtimer: interrupt took 5451385 ns\n  BTRFS error (device dm-3): cow_file_range failed, root=4957 inode=257 start=1605632 len=69632: -28\n  BTRFS error (device dm-3): run_delalloc_nocow failed, root=4957 inode=257 start=1605632 len=69632: -28\n  BTRFS error (device dm-3): failed to run delalloc range, root=4957 ino=257 folio=1572864 submit_bitmap=8-15 start=1605632 len=69632: -28\n  ------------[ cut here ]------------\n  WARNING: CPU: 2 PID: 3020984 at ordered-data.c:360 can_finish_ordered_extent+0x370/0x3b8 [btrfs]\n  CPU: 2 UID: 0 PID: 3020984 Comm: kworker/u24:1 Tainted: G           OE      6.13.0-rc1-custom+ #89\n  Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE\n  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n  Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]\n  pc : can_finish_ordered_extent+0x370/0x3b8 [btrfs]\n  lr : can_finish_ordered_extent+0x1ec/0x3b8 [btrfs]\n  Call trace:\n   can_finish_ordered_extent+0x370/0x3b8 [btrfs] (P)\n   can_finish_ordered_extent+0x1ec/0x3b8 [btrfs] (L)\n   btrfs_mark_ordered_io_finished+0x130/0x2b8 [btrfs]\n   extent_writepage+0x10c/0x3b8 [btrfs]\n   extent_write_cache_pages+0x21c/0x4e8 [btrfs]\n   btrfs_writepages+0x94/0x160 [btrfs]\n   do_writepages+0x74/0x190\n   filemap_fdatawrite_wbc+0x74/0xa0\n   start_delalloc_inodes+0x17c/0x3b0 [btrfs]\n   btrfs_start_delalloc_roots+0x17c/0x288 [btrfs]\n   shrink_delalloc+0x11c/0x280 [btrfs]\n   flush_space+0x288/0x328 [btrfs]\n   btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]\n   process_one_work+0x228/0x680\n   worker_thread+0x1bc/0x360\n   kthread+0x100/0x118\n   ret_from_fork+0x10/0x20\n  ---[ end trace 0000000000000000 ]---\n  BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1605632 OE len=16384 to_dec=16384 left=0\n  BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1622016 OE len=12288 to_dec=12288 left=0\n  Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008\n  BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1634304 OE len=8192 to_dec=4096 left=0\n  CPU: 1 UID: 0 PID: 3286940 Comm: kworker/u24:3 Tainted: G        W  OE      6.13.0-rc1-custom+ #89\n  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n  Workqueue:  btrfs_work_helper [btrfs] (btrfs-endio-write)\n  pstate: 404000c5 (nZcv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n  pc : process_one_work+0x110/0x680\n  lr : worker_thread+0x1bc/0x360\n  Call trace:\n   process_one_work+0x110/0x680 (P)\n   worker_thread+0x1bc/0x360 (L)\n   worker_thread+0x1bc/0x360\n   kthread+0x100/0x118\n   ret_from_fork+0x10/0x20\n  Code: f84086a1 f9000fe1 53041c21 b9003361 (f9400661)\n  ---[ end trace 0000000000000000 ]---\n  Kernel panic - not syncing: Oops: Fatal exception\n  SMP: stopping secondary CPUs\n  SMP: failed to stop secondary CPUs 2-3\n  Dumping ftrace buffer:\n     (ftrace buffer empty)\n  Kernel Offset: 0x275bb9540000 from 0xffff800080000000\n  PHYS_OFFSET: 0xffff8fbba0000000\n  CPU features: 0x100,00000070,00801250,8201720b\n\n[CAUSE]\nThe above warning is triggered immediately after the delalloc range\nfailure, this happens in the following sequence:\n\n- Range [1568K, 1636K) is dirty\n\n   1536K  1568K     1600K    1636K  1664K\n   |      |/////////|////////|      |\n\n  Where 1536K, 1600K and 1664K are page boundaries (64K page size)\n\n- Enter extent_writepage() for page 1536K\n\n- Enter run_delalloc_nocow() with locke\n---truncated---",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/0283ee1912c8e243c931f4ee5b3672e954fe0384",
            "https://git.kernel.org/stable/c/21333148b5c9e52f41fafcedec3810b56a5e0e40",
            "https://git.kernel.org/stable/c/72dad8e377afa50435940adfb697e070d3556670"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:4.19.73:*:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21844",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: Add check for next_buffer in receive_encrypted_standard()\n\nAdd check for the return value of cifs_buf_get() and cifs_small_buf_get()\nin receive_encrypted_standard() to prevent null pointer dereference.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/24e8e4523d3071bc5143b0db9127d511489f7b3b",
            "https://git.kernel.org/stable/c/554736b583f529ee159aa95af9a0cbc12b5ffc96",
            "https://git.kernel.org/stable/c/860ca5e50f73c2a1cef7eefc9d39d04e275417f7",
            "https://git.kernel.org/stable/c/9e5d99a4cf2e23c716b44862975548415fae5391",
            "https://git.kernel.org/stable/c/a9b0b4b29877cb4dc5d0842b59b5ccbacddb85bd",
            "https://git.kernel.org/stable/c/f277e479eea3d1aa18bc712abe1d2bf3dece2e30",
            "https://git.kernel.org/stable/c/f618aeb6cad2307e48a641379db610abcf593edf"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:5.10.211:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:5.15.150:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21845",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmtd: spi-nor: sst: Fix SST write failure\n\n'commit 18bcb4aa54ea (\"mtd: spi-nor: sst: Factor out common write operation\nto `sst_nor_write_data()`\")' introduced a bug where only one byte of data\nis written, regardless of the number of bytes passed to\nsst_nor_write_data(), causing a kernel crash during the write operation.\nEnsure the correct number of bytes are written as passed to\nsst_nor_write_data().\n\nCall trace:\n[   57.400180] ------------[ cut here ]------------\n[   57.404842] While writing 2 byte written 1 bytes\n[   57.409493] WARNING: CPU: 0 PID: 737 at drivers/mtd/spi-nor/sst.c:187 sst_nor_write_data+0x6c/0x74\n[   57.418464] Modules linked in:\n[   57.421517] CPU: 0 UID: 0 PID: 737 Comm: mtd_debug Not tainted 6.12.0-g5ad04afd91f9 #30\n[   57.429517] Hardware name: Xilinx Versal A2197 Processor board revA - x-prc-02 revA (DT)\n[   57.437600] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   57.444557] pc : sst_nor_write_data+0x6c/0x74\n[   57.448911] lr : sst_nor_write_data+0x6c/0x74\n[   57.453264] sp : ffff80008232bb40\n[   57.456570] x29: ffff80008232bb40 x28: 0000000000010000 x27: 0000000000000001\n[   57.463708] x26: 000000000000ffff x25: 0000000000000000 x24: 0000000000000000\n[   57.470843] x23: 0000000000010000 x22: ffff80008232bbf0 x21: ffff000816230000\n[   57.477978] x20: ffff0008056c0080 x19: 0000000000000002 x18: 0000000000000006\n[   57.485112] x17: 0000000000000000 x16: 0000000000000000 x15: ffff80008232b580\n[   57.492246] x14: 0000000000000000 x13: ffff8000816d1530 x12: 00000000000004a4\n[   57.499380] x11: 000000000000018c x10: ffff8000816fd530 x9 : ffff8000816d1530\n[   57.506515] x8 : 00000000fffff7ff x7 : ffff8000816fd530 x6 : 0000000000000001\n[   57.513649] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000\n[   57.520782] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0008049b0000\n[   57.527916] Call trace:\n[   57.530354]  sst_nor_write_data+0x6c/0x74\n[   57.534361]  sst_nor_write+0xb4/0x18c\n[   57.538019]  mtd_write_oob_std+0x7c/0x88\n[   57.541941]  mtd_write_oob+0x70/0xbc\n[   57.545511]  mtd_write+0x68/0xa8\n[   57.548733]  mtdchar_write+0x10c/0x290\n[   57.552477]  vfs_write+0xb4/0x3a8\n[   57.555791]  ksys_write+0x74/0x10c\n[   57.559189]  __arm64_sys_write+0x1c/0x28\n[   57.563109]  invoke_syscall+0x54/0x11c\n[   57.566856]  el0_svc_common.constprop.0+0xc0/0xe0\n[   57.571557]  do_el0_svc+0x1c/0x28\n[   57.574868]  el0_svc+0x30/0xcc\n[   57.577921]  el0t_64_sync_handler+0x120/0x12c\n[   57.582276]  el0t_64_sync+0x190/0x194\n[   57.585933] ---[ end trace 0000000000000000 ]---\n\n[pratyush@kernel.org: add Cc stable tag]",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/539bd20352832b9244238a055eb169ccf1c41ff6",
            "https://git.kernel.org/stable/c/9553391f32f8c43e12fc7c04e1035160b5ea20bf",
            "https://git.kernel.org/stable/c/bb1accc7e0f688886f0c634f2e878b8ac4ee6a58"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21846",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nacct: perform last write from workqueue\n\nIn [1] it was reported that the acct(2) system call can be used to\ntrigger NULL deref in cases where it is set to write to a file that\ntriggers an internal lookup. This can e.g., happen when pointing acc(2)\nto /sys/power/resume. At the point the where the write to this file\nhappens the calling task has already exited and called exit_fs(). A\nlookup will thus trigger a NULL-deref when accessing current->fs.\n\nReorganize the code so that the the final write happens from the\nworkqueue but with the caller's credentials. This preserves the\n(strange) permission model and has almost no regression risk.\n\nThis api should stop to exist though.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/56d5f3eba3f5de0efdd556de4ef381e109b973a9",
            "https://git.kernel.org/stable/c/5a59ced8ffc71973d42c82484a719c8f6ac8f7f7",
            "https://git.kernel.org/stable/c/5c928e14a2ccd99462f2351ead627b58075bb736",
            "https://git.kernel.org/stable/c/5d5b936cfa4b0d5670ca7420ef165a074bc008eb",
            "https://git.kernel.org/stable/c/5ee8da9bea70dda492d61f075658939af33d8410",
            "https://git.kernel.org/stable/c/8acbf4a88c6a98c8ed00afd1a7d1abcca9b4735e",
            "https://git.kernel.org/stable/c/a8136afca090412a36429cb6c2543c714d9c0f84",
            "https://git.kernel.org/stable/c/b03782ae707cc45e65242c7cddd8e28f1c22cde5"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21847",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: SOF: stream-ipc: Check for cstream nullity in sof_ipc_msg_data()\n\nThe nullity of sps->cstream should be checked similarly as it is done in\nsof_set_stream_data_offset() function.\nAssuming that it is not NULL if sps->stream is NULL is incorrect and can\nlead to NULL pointer dereference.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/2b3878baf90918a361a3dfd3513025100b1b40b6",
            "https://git.kernel.org/stable/c/62ab1ae5511c59b5f0bf550136ff321331adca9f",
            "https://git.kernel.org/stable/c/6c18f5eb2043ebf4674c08a9690218dc818a11ab",
            "https://git.kernel.org/stable/c/d8d99c3b5c485f339864aeaa29f76269cc0ea975"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21848",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfp: bpf: Add check for nfp_app_ctrl_msg_alloc()\n\nAdd check for the return value of nfp_app_ctrl_msg_alloc() in\nnfp_bpf_cmsg_alloc() to prevent null pointer dereference.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/1358d8e07afdf21d49ca6f00c56048442977e00a",
            "https://git.kernel.org/stable/c/29ccb1e4040da6ff02b7e64efaa2f8e6bf06020d",
            "https://git.kernel.org/stable/c/878e7b11736e062514e58f3b445ff343e6705537",
            "https://git.kernel.org/stable/c/897c32cd763fd11d0b6ed024c52f44d2475bb820",
            "https://git.kernel.org/stable/c/924b239f9704566e0d86abd894d2d64bd73c11eb",
            "https://git.kernel.org/stable/c/bd97f60750bb581f07051f98e31dfda59d3a783b",
            "https://git.kernel.org/stable/c/d64c6ca420019712e194fe095b55f87363e22a9a",
            "https://git.kernel.org/stable/c/e976ea6c5e1b005c64467cbf94a8577aae9c7d81"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21849",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915/gt: Use spin_lock_irqsave() in interruptible context\n\nspin_lock/unlock() functions used in interrupt contexts could\nresult in a deadlock, as seen in GitLab issue #13399,\nwhich occurs when interrupt comes in while holding a lock.\n\nTry to remedy the problem by saving irq state before spin lock\nacquisition.\n\nv2: add irqs' state save/restore calls to all locks/unlocks in\n signal_irq_work() execution (Maciej)\n\nv3: use with spin_lock_irqsave() in guc_lrc_desc_unpin() instead\n of other lock/unlock calls and add Fixes and Cc tags (Tvrtko);\n change title and commit message\n\n(cherry picked from commit c088387ddd6482b40f21ccf23db1125e8fa4af7e)",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/2bf1f4c129db7a10920655b000f0292f1ee509c2",
            "https://git.kernel.org/stable/c/47ae46ac5407646420e06b78e0dad331e56a4bb4",
            "https://git.kernel.org/stable/c/e49477f7f78598295551d486ecc7f020d796432e"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21850",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvmet: Fix crash when a namespace is disabled\n\nThe namespace percpu counter protects pending I/O, and we can\nonly safely diable the namespace once the counter drop to zero.\nOtherwise we end up with a crash when running blktests/nvme/058\n(eg for loop transport):\n\n[ 2352.930426] [  T53909] Oops: general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] PREEMPT SMP KASAN PTI\n[ 2352.930431] [  T53909] KASAN: null-ptr-deref in range [0x0000000000000028-0x000000000000002f]\n[ 2352.930434] [  T53909] CPU: 3 UID: 0 PID: 53909 Comm: kworker/u16:5 Tainted: G        W          6.13.0-rc6 #232\n[ 2352.930438] [  T53909] Tainted: [W]=WARN\n[ 2352.930440] [  T53909] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014\n[ 2352.930443] [  T53909] Workqueue: nvmet-wq nvme_loop_execute_work [nvme_loop]\n[ 2352.930449] [  T53909] RIP: 0010:blkcg_set_ioprio+0x44/0x180\n\nas the queue is already torn down when calling submit_bio();\n\nSo we need to init the percpu counter in nvmet_ns_enable(), and\nwait for it to drop to zero in nvmet_ns_disable() to avoid having\nI/O pending after the namespace has been disabled.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/4082326807072b71496501b6a0c55ffe8d5092a5",
            "https://git.kernel.org/stable/c/cc0607594f6813342b27c752c6fb6f6eb9980cb5"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21851",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix softlockup in arena_map_free on 64k page kernel\n\nOn an aarch64 kernel with CONFIG_PAGE_SIZE_64KB=y,\narena_htab tests cause a segmentation fault and soft lockup.\nThe same failure is not observed with 4k pages on aarch64.\n\nIt turns out arena_map_free() is calling\napply_to_existing_page_range() with the address returned by\nbpf_arena_get_kern_vm_start().  If this address is not page-aligned\nthe code ends up calling apply_to_pte_range() with that unaligned\naddress causing soft lockup.\n\nFix it by round up GUARD_SZ to PAGE_SIZE << 1 so that the\ndivision by 2 in bpf_arena_get_kern_vm_start() returns\na page-aligned value.",
        "Severity": "LOW",
        "Patches": [
            "https://git.kernel.org/stable/c/517e8a7835e8cfb398a0aeb0133de50e31cae32b",
            "https://git.kernel.org/stable/c/787d556a3de447e70964a4bdeba9196f62a62b1e",
            "https://git.kernel.org/stable/c/c1f3f3892d4526f18aaeffdb6068ce861e793ee3"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.9:-:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21852",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: Add rx_skb of kfree_skb to raw_tp_null_args[].\n\nYan Zhai reported a BPF prog could trigger a null-ptr-deref [0]\nin trace_kfree_skb if the prog does not check if rx_sk is NULL.\n\nCommit c53795d48ee8 (\"net: add rx_sk to trace_kfree_skb\") added\nrx_sk to trace_kfree_skb, but rx_sk is optional and could be NULL.\n\nLet's add kfree_skb to raw_tp_null_args[] to let the BPF verifier\nvalidate such a prog and prevent the issue.\n\nNow we fail to load such a prog:\n\n  libbpf: prog 'drop': -- BEGIN PROG LOAD LOG --\n  0: R1=ctx() R10=fp0\n  ; int BPF_PROG(drop, struct sk_buff *skb, void *location, @ kfree_skb_sk_null.bpf.c:21\n  0: (79) r3 = *(u64 *)(r1 +24)\n  func 'kfree_skb' arg3 has btf_id 5253 type STRUCT 'sock'\n  1: R1=ctx() R3_w=trusted_ptr_or_null_sock(id=1)\n  ; bpf_printk(\"sk: %d, %d\\n\", sk, sk->__sk_common.skc_family); @ kfree_skb_sk_null.bpf.c:24\n  1: (69) r4 = *(u16 *)(r3 +16)\n  R3 invalid mem access 'trusted_ptr_or_null_'\n  processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0\n  -- END PROG LOAD LOG --\n\nNote this fix requires commit 838a10bd2ebf (\"bpf: Augment raw_tp\narguments with PTR_MAYBE_NULL\").\n\n[0]:\nBUG: kernel NULL pointer dereference, address: 0000000000000010\n PF: supervisor read access in kernel mode\n PF: error_code(0x0000) - not-present page\nPGD 0 P4D 0\nPREEMPT SMP\nRIP: 0010:bpf_prog_5e21a6db8fcff1aa_drop+0x10/0x2d\nCall Trace:\n <TASK>\n ? __die+0x1f/0x60\n ? page_fault_oops+0x148/0x420\n ? search_bpf_extables+0x5b/0x70\n ? fixup_exception+0x27/0x2c0\n ? exc_page_fault+0x75/0x170\n ? asm_exc_page_fault+0x22/0x30\n ? bpf_prog_5e21a6db8fcff1aa_drop+0x10/0x2d\n bpf_trace_run4+0x68/0xd0\n ? unix_stream_connect+0x1f4/0x6f0\n sk_skb_reason_drop+0x90/0x120\n unix_stream_connect+0x1f4/0x6f0\n __sys_connect+0x7f/0xb0\n __x64_sys_connect+0x14/0x20\n do_syscall_64+0x47/0xc30\n entry_SYSCALL_64_after_hwframe+0x4b/0x53",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/4dba79c1e7aad6620bbb707b6c4459380fd90860",
            "https://git.kernel.org/stable/c/5da7e15fb5a12e78de974d8908f348e279922ce9",
            "https://git.kernel.org/stable/c/f579afacd0a66971fc8481f30d2d377e230a8342"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21853",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: avoid holding freeze_mutex during mmap operation\n\nWe use map->freeze_mutex to prevent races between map_freeze() and\nmemory mapping BPF map contents with writable permissions. The way we\nnaively do this means we'll hold freeze_mutex for entire duration of all\nthe mm and VMA manipulations, which is completely unnecessary. This can\npotentially also lead to deadlocks, as reported by syzbot in [0].\n\nSo, instead, hold freeze_mutex only during writeability checks, bump\n(proactively) \"write active\" count for the map, unlock the mutex and\nproceed with mmap logic. And only if something went wrong during mmap\nlogic, then undo that \"write active\" counter increment.\n\n  [0] https://lore.kernel.org/bpf/678dcbc9.050a0220.303755.0066.GAE@google.com/",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/271e49f8a58edba65bc2b1250a0abaa98c4bfdbe",
            "https://git.kernel.org/stable/c/29cfda62ab4d92ab94123813db49ab76c1e61b29",
            "https://git.kernel.org/stable/c/bc27c52eea189e8f7492d40739b7746d67b65beb",
            "https://git.kernel.org/stable/c/d95607a5f2f9bb08194c9deaf4a5f3e8ba59a9d4"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21854",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsockmap, vsock: For connectible sockets allow only connected\n\nsockmap expects all vsocks to have a transport assigned, which is expressed\nin vsock_proto::psock_update_sk_prot(). However, there is an edge case\nwhere an unconnected (connectible) socket may lose its previously assigned\ntransport. This is handled with a NULL check in the vsock/BPF recv path.\n\nAnother design detail is that listening vsocks are not supposed to have any\ntransport assigned at all. Which implies they are not supported by the\nsockmap. But this is complicated by the fact that a socket, before\nswitching to TCP_LISTEN, may have had some transport assigned during a\nfailed connect() attempt. Hence, we may end up with a listening vsock in a\nsockmap, which blows up quickly:\n\nKASAN: null-ptr-deref in range [0x0000000000000120-0x0000000000000127]\nCPU: 7 UID: 0 PID: 56 Comm: kworker/7:0 Not tainted 6.14.0-rc1+\nWorkqueue: vsock-loopback vsock_loopback_work\nRIP: 0010:vsock_read_skb+0x4b/0x90\nCall Trace:\n sk_psock_verdict_data_ready+0xa4/0x2e0\n virtio_transport_recv_pkt+0x1ca8/0x2acc\n vsock_loopback_work+0x27d/0x3f0\n process_one_work+0x846/0x1420\n worker_thread+0x5b3/0xf80\n kthread+0x35a/0x700\n ret_from_fork+0x2d/0x70\n ret_from_fork_asm+0x1a/0x30\n\nFor connectible sockets, instead of relying solely on the state of\nvsk->transport, tell sockmap to only allow those representing established\nconnections. This aligns with the behaviour for AF_INET and AF_UNIX.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/22b683217ad2112791a708693cb236507abd637a",
            "https://git.kernel.org/stable/c/8fb5bb169d17cdd12c2dcc2e96830ed487d77a0f",
            "https://git.kernel.org/stable/c/cc9a7832ede53ade1ba9991f0e27314caa4029d8",
            "https://git.kernel.org/stable/c/f7b473e35986835cc2813fef7b9d40336a09247e"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21855",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nibmvnic: Don't reference skb after sending to VIOS\n\nPreviously, after successfully flushing the xmit buffer to VIOS,\nthe tx_bytes stat was incremented by the length of the skb.\n\nIt is invalid to access the skb memory after sending the buffer to\nthe VIOS because, at any point after sending, the VIOS can trigger\nan interrupt to free this memory. A race between reading skb->len\nand freeing the skb is possible (especially during LPM) and will\nresult in use-after-free:\n ==================================================================\n BUG: KASAN: slab-use-after-free in ibmvnic_xmit+0x75c/0x1808 [ibmvnic]\n Read of size 4 at addr c00000024eb48a70 by task hxecom/14495\n <...>\n Call Trace:\n [c000000118f66cf0] [c0000000018cba6c] dump_stack_lvl+0x84/0xe8 (unreliable)\n [c000000118f66d20] [c0000000006f0080] print_report+0x1a8/0x7f0\n [c000000118f66df0] [c0000000006f08f0] kasan_report+0x128/0x1f8\n [c000000118f66f00] [c0000000006f2868] __asan_load4+0xac/0xe0\n [c000000118f66f20] [c0080000046eac84] ibmvnic_xmit+0x75c/0x1808 [ibmvnic]\n [c000000118f67340] [c0000000014be168] dev_hard_start_xmit+0x150/0x358\n <...>\n Freed by task 0:\n kasan_save_stack+0x34/0x68\n kasan_save_track+0x2c/0x50\n kasan_save_free_info+0x64/0x108\n __kasan_mempool_poison_object+0x148/0x2d4\n napi_skb_cache_put+0x5c/0x194\n net_tx_action+0x154/0x5b8\n handle_softirqs+0x20c/0x60c\n do_softirq_own_stack+0x6c/0x88\n <...>\n The buggy address belongs to the object at c00000024eb48a00 which\n  belongs to the cache skbuff_head_cache of size 224\n==================================================================",
        "Severity": "HIGH",
        "Patches": [
            "https://git.kernel.org/stable/c/093b0e5c90592773863f300b908b741622eef597",
            "https://git.kernel.org/stable/c/25dddd01dcc8ef3acff964dbb32eeb0d89f098e9",
            "https://git.kernel.org/stable/c/501ac6a7e21b82e05207c6b4449812d82820f306",
            "https://git.kernel.org/stable/c/abaff2717470e4b5b7c0c3a90e128b211a23da09",
            "https://git.kernel.org/stable/c/bdf5d13aa05ec314d4385b31ac974d6c7e0997c9"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21856",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/ism: add release function for struct device\n\nAccording to device_release() in /drivers/base/core.c,\na device without a release function is a broken device\nand must be fixed.\n\nThe current code directly frees the device after calling device_add()\nwithout waiting for other kernel parts to release their references.\nThus, a reference could still be held to a struct device,\ne.g., by sysfs, leading to potential use-after-free\nissues if a proper release function is not set.",
        "Severity": "HIGH",
        "Patches": [
            "https://git.kernel.org/stable/c/0505ff2936f166405d81d0d454a81d9c14124344",
            "https://git.kernel.org/stable/c/915e34d5ad35a6a9e56113f852ade4a730fb88f0",
            "https://git.kernel.org/stable/c/940d15254d2216b585558bcf36312da50074e711",
            "https://git.kernel.org/stable/c/e26e8ac27351f457091459a0a355bacd06d5bb2b"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21857",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: cls_api: fix error handling causing NULL dereference\n\ntcf_exts_miss_cookie_base_alloc() calls xa_alloc_cyclic() which can\nreturn 1 if the allocation succeeded after wrapping. This was treated as\nan error, with value 1 returned to caller tcf_exts_init_ex() which sets\nexts->actions to NULL and returns 1 to caller fl_change().\n\nfl_change() treats err == 1 as success, calling tcf_exts_validate_ex()\nwhich calls tcf_action_init() with exts->actions as argument, where it\nis dereferenced.\n\nExample trace:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000000\nCPU: 114 PID: 16151 Comm: handler114 Kdump: loaded Not tainted 5.14.0-503.16.1.el9_5.x86_64 #1\nRIP: 0010:tcf_action_init+0x1f8/0x2c0\nCall Trace:\n tcf_action_init+0x1f8/0x2c0\n tcf_exts_validate_ex+0x175/0x190\n fl_change+0x537/0x1120 [cls_flower]",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/071ed42cff4fcdd89025d966d48eabef59913bf2",
            "https://git.kernel.org/stable/c/3c74b5787caf59bb1e9c5fe0a360643a71eb1e8a",
            "https://git.kernel.org/stable/c/3e4c56cf41876ef2a82f0877fe2a67648f8632b8",
            "https://git.kernel.org/stable/c/de4b679aa3b4da7ec34f639df068b914f20e3c3c"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21858",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngeneve: Fix use-after-free in geneve_find_dev().\n\nsyzkaller reported a use-after-free in geneve_find_dev() [0]\nwithout repro.\n\ngeneve_configure() links struct geneve_dev.next to\nnet_generic(net, geneve_net_id)->geneve_list.\n\nThe net here could differ from dev_net(dev) if IFLA_NET_NS_PID,\nIFLA_NET_NS_FD, or IFLA_TARGET_NETNSID is set.\n\nWhen dev_net(dev) is dismantled, geneve_exit_batch_rtnl() finally\ncalls unregister_netdevice_queue() for each dev in the netns,\nand later the dev is freed.\n\nHowever, its geneve_dev.next is still linked to the backend UDP\nsocket netns.\n\nThen, use-after-free will occur when another geneve dev is created\nin the netns.\n\nLet's call geneve_dellink() instead in geneve_destroy_tunnels().\n\n[0]:\nBUG: KASAN: slab-use-after-free in geneve_find_dev drivers/net/geneve.c:1295 [inline]\nBUG: KASAN: slab-use-after-free in geneve_configure+0x234/0x858 drivers/net/geneve.c:1343\nRead of size 2 at addr ffff000054d6ee24 by task syz.1.4029/13441\n\nCPU: 1 UID: 0 PID: 13441 Comm: syz.1.4029 Not tainted 6.13.0-g0ad9617c78ac #24 dc35ca22c79fb82e8e7bc5c9c9adafea898b1e3d\nHardware name: linux,dummy-virt (DT)\nCall trace:\n show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:466 (C)\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x16c/0x6f0 mm/kasan/report.c:489\n kasan_report+0xc0/0x120 mm/kasan/report.c:602\n __asan_report_load2_noabort+0x20/0x30 mm/kasan/report_generic.c:379\n geneve_find_dev drivers/net/geneve.c:1295 [inline]\n geneve_configure+0x234/0x858 drivers/net/geneve.c:1343\n geneve_newlink+0xb8/0x128 drivers/net/geneve.c:1634\n rtnl_newlink_create+0x23c/0x868 net/core/rtnetlink.c:3795\n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]\n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021\n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911\n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543\n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938\n netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]\n netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1348\n netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1892\n sock_sendmsg_nosec net/socket.c:713 [inline]\n __sock_sendmsg net/socket.c:728 [inline]\n ____sys_sendmsg+0x410/0x6f8 net/socket.c:2568\n ___sys_sendmsg+0x178/0x1d8 net/socket.c:2622\n __sys_sendmsg net/socket.c:2654 [inline]\n __do_sys_sendmsg net/socket.c:2659 [inline]\n __se_sys_sendmsg net/socket.c:2657 [inline]\n __arm64_sys_sendmsg+0x12c/0x1c8 net/socket.c:2657\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151\n el0_svc+0x4c/0xa8 arch/arm64/kernel/entry-common.c:744\n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:762\n el0t_64_sync+0x198/0x1a0 arch/arm64/kernel/entry.S:600\n\nAllocated by task 13247:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x30/0x68 mm/kasan/common.c:68\n kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4298 [inline]\n __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4304\n __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:645\n alloc_netdev_mqs+0xb8/0x11a0 net/core/dev.c:11470\n rtnl_create_link+0x2b8/0xb50 net/core/rtnetlink.c:3604\n rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3780\n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]\n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021\n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911\n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543\n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938\n netlink_unicast_kernel net/netlink/af_n\n---truncated---",
        "Severity": "HIGH",
        "Patches": [
            "https://git.kernel.org/stable/c/3ce92ca990cfac88a87c61df3cc0b5880e688ecf",
            "https://git.kernel.org/stable/c/5a0538ac6826807d6919f6aecbb8996c2865af2c",
            "https://git.kernel.org/stable/c/788dbca056a8783ec063da3c9d49a3a71c76c283",
            "https://git.kernel.org/stable/c/904e746b2e7fa952ab8801b303ce826a63153d78",
            "https://git.kernel.org/stable/c/9593172d93b9f91c362baec4643003dc29802929",
            "https://git.kernel.org/stable/c/d5e86e27de0936f3cb0a299ce519d993e9cf3886",
            "https://git.kernel.org/stable/c/da9b0ae47f084014b1e4b3f31f70a0defd047ff3",
            "https://git.kernel.org/stable/c/f74f6560146714241c6e167b03165ee77a86e316"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21859",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: gadget: f_midi: f_midi_complete to call queue_work\n\nWhen using USB MIDI, a lock is attempted to be acquired twice through a\nre-entrant call to f_midi_transmit, causing a deadlock.\n\nFix it by using queue_work() to schedule the inner f_midi_transmit() via\na high priority work queue from the completion handler.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/1f10923404705a94891e612dff3b75e828a78368",
            "https://git.kernel.org/stable/c/24a942610ee9bafb2692a456ae850c5b2e409b05",
            "https://git.kernel.org/stable/c/4ab37fcb42832cdd3e9d5e50653285ca84d6686f",
            "https://git.kernel.org/stable/c/727dee0857946b85232526de4f5a957fe163e89a",
            "https://git.kernel.org/stable/c/8aa6b4be1f4efccbfc533e6ec8841d26e4fa8dba",
            "https://git.kernel.org/stable/c/b09957657d7767d164b3432af2129bd72947553c",
            "https://git.kernel.org/stable/c/deeee3adb2c01eedab32c3b4519337689ad02e8a",
            "https://git.kernel.org/stable/c/e9fec6f42c45db2f62dc373fb1a10d2488c04e79"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21860",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/zswap: fix inconsistency when zswap_store_page() fails\n\nCommit b7c0ccdfbafd (\"mm: zswap: support large folios in zswap_store()\")\nskips charging any zswap entries when it failed to zswap the entire folio.\n\nHowever, when some base pages are zswapped but it failed to zswap the\nentire folio, the zswap operation is rolled back.  When freeing zswap\nentries for those pages, zswap_entry_free() uncharges the zswap entries\nthat were not previously charged, causing zswap charging to become\ninconsistent.\n\nThis inconsistency triggers two warnings with following steps:\n  # On a machine with 64GiB of RAM and 36GiB of zswap\n  $ stress-ng --bigheap 2 # wait until the OOM-killer kills stress-ng\n  $ sudo reboot\n\n  The two warnings are:\n    in mm/memcontrol.c:163, function obj_cgroup_release():\n      WARN_ON_ONCE(nr_bytes & (PAGE_SIZE - 1));\n\n    in mm/page_counter.c:60, function page_counter_cancel():\n      if (WARN_ONCE(new < 0, \"page_counter underflow: %ld nr_pages=%lu\\n\",\n\t  new, nr_pages))\n\nzswap_stored_pages also becomes inconsistent in the same way.\n\nAs suggested by Kanchana, increment zswap_stored_pages and charge zswap\nentries within zswap_store_page() when it succeeds.  This way,\nzswap_entry_free() will decrement the counter and uncharge the entries\nwhen it failed to zswap the entire folio.\n\nWhile this could potentially be optimized by batching objcg charging and\nincrementing the counter, let's focus on fixing the bug this time and\nleave the optimization for later after some evaluation.\n\nAfter resolving the inconsistency, the warnings disappear.\n\n[42.hyeyoo@gmail.com: refactor zswap_store_page()]\n  Link: https://lkml.kernel.org/r/20250131082037.2426-1-42.hyeyoo@gmail.com",
        "Severity": "LOW",
        "Patches": [
            "https://git.kernel.org/stable/c/63895d20d63b446f5049a963983489319c2ea3e2",
            "https://git.kernel.org/stable/c/a3652f5552b20903315612da487a7be2b95394d5"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21861",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/migrate_device: don't add folio to be freed to LRU in migrate_device_finalize()\n\nIf migration succeeded, we called\nfolio_migrate_flags()->mem_cgroup_migrate() to migrate the memcg from the\nold to the new folio.  This will set memcg_data of the old folio to 0.\n\nSimilarly, if migration failed, memcg_data of the dst folio is left unset.\n\nIf we call folio_putback_lru() on such folios (memcg_data == 0), we will\nadd the folio to be freed to the LRU, making memcg code unhappy.  Running\nthe hmm selftests:\n\n  # ./hmm-tests\n  ...\n  #  RUN           hmm.hmm_device_private.migrate ...\n  [  102.078007][T14893] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x7ff27d200 pfn:0x13cc00\n  [  102.079974][T14893] anon flags: 0x17ff00000020018(uptodate|dirty|swapbacked|node=0|zone=2|lastcpupid=0x7ff)\n  [  102.082037][T14893] raw: 017ff00000020018 dead000000000100 dead000000000122 ffff8881353896c9\n  [  102.083687][T14893] raw: 00000007ff27d200 0000000000000000 00000001ffffffff 0000000000000000\n  [  102.085331][T14893] page dumped because: VM_WARN_ON_ONCE_FOLIO(!memcg && !mem_cgroup_disabled())\n  [  102.087230][T14893] ------------[ cut here ]------------\n  [  102.088279][T14893] WARNING: CPU: 0 PID: 14893 at ./include/linux/memcontrol.h:726 folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.090478][T14893] Modules linked in:\n  [  102.091244][T14893] CPU: 0 UID: 0 PID: 14893 Comm: hmm-tests Not tainted 6.13.0-09623-g6c216bc522fd #151\n  [  102.093089][T14893] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014\n  [  102.094848][T14893] RIP: 0010:folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.096104][T14893] Code: ...\n  [  102.099908][T14893] RSP: 0018:ffffc900236c37b0 EFLAGS: 00010293\n  [  102.101152][T14893] RAX: 0000000000000000 RBX: ffffea0004f30000 RCX: ffffffff8183f426\n  [  102.102684][T14893] RDX: ffff8881063cb880 RSI: ffffffff81b8117f RDI: ffff8881063cb880\n  [  102.104227][T14893] RBP: 0000000000000000 R08: 0000000000000005 R09: 0000000000000000\n  [  102.105757][T14893] R10: 0000000000000001 R11: 0000000000000002 R12: ffffc900236c37d8\n  [  102.107296][T14893] R13: ffff888277a2bcb0 R14: 000000000000001f R15: 0000000000000000\n  [  102.108830][T14893] FS:  00007ff27dbdd740(0000) GS:ffff888277a00000(0000) knlGS:0000000000000000\n  [  102.110643][T14893] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [  102.111924][T14893] CR2: 00007ff27d400000 CR3: 000000010866e000 CR4: 0000000000750ef0\n  [  102.113478][T14893] PKRU: 55555554\n  [  102.114172][T14893] Call Trace:\n  [  102.114805][T14893]  <TASK>\n  [  102.115397][T14893]  ? folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.116547][T14893]  ? __warn.cold+0x110/0x210\n  [  102.117461][T14893]  ? folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.118667][T14893]  ? report_bug+0x1b9/0x320\n  [  102.119571][T14893]  ? handle_bug+0x54/0x90\n  [  102.120494][T14893]  ? exc_invalid_op+0x17/0x50\n  [  102.121433][T14893]  ? asm_exc_invalid_op+0x1a/0x20\n  [  102.122435][T14893]  ? __wake_up_klogd.part.0+0x76/0xd0\n  [  102.123506][T14893]  ? dump_page+0x4f/0x60\n  [  102.124352][T14893]  ? folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.125500][T14893]  folio_batch_move_lru+0xd4/0x200\n  [  102.126577][T14893]  ? __pfx_lru_add+0x10/0x10\n  [  102.127505][T14893]  __folio_batch_add_and_move+0x391/0x720\n  [  102.128633][T14893]  ? __pfx_lru_add+0x10/0x10\n  [  102.129550][T14893]  folio_putback_lru+0x16/0x80\n  [  102.130564][T14893]  migrate_device_finalize+0x9b/0x530\n  [  102.131640][T14893]  dmirror_migrate_to_device.constprop.0+0x7c5/0xad0\n  [  102.133047][T14893]  dmirror_fops_unlocked_ioctl+0x89b/0xc80\n\nLikely, nothing else goes wrong: putting the last folio reference will\nremove the folio from the LRU again.  So besides memcg complaining, adding\nthe folio to be freed to the LRU is just an unnecessary step.\n\nThe new flow resembles what we have in migrate_folio_move(): add the dst\nto the lru, rem\n---truncated---",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/069dd21ea8262204f94737878389c2815a054a9e",
            "https://git.kernel.org/stable/c/3f9240d59e9a95d19f06120bfd1d0e681c6c0ac7",
            "https://git.kernel.org/stable/c/41cddf83d8b00f29fd105e7a0777366edc69a5cf"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21862",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrop_monitor: fix incorrect initialization order\n\nSyzkaller reports the following bug:\n\nBUG: spinlock bad magic on CPU#1, syz-executor.0/7995\n lock: 0xffff88805303f3e0, .magic: 00000000, .owner: <none>/-1, .owner_cpu: 0\nCPU: 1 PID: 7995 Comm: syz-executor.0 Tainted: G            E     5.10.209+ #1\nHardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x119/0x179 lib/dump_stack.c:118\n debug_spin_lock_before kernel/locking/spinlock_debug.c:83 [inline]\n do_raw_spin_lock+0x1f6/0x270 kernel/locking/spinlock_debug.c:112\n __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:117 [inline]\n _raw_spin_lock_irqsave+0x50/0x70 kernel/locking/spinlock.c:159\n reset_per_cpu_data+0xe6/0x240 [drop_monitor]\n net_dm_cmd_trace+0x43d/0x17a0 [drop_monitor]\n genl_family_rcv_msg_doit+0x22f/0x330 net/netlink/genetlink.c:739\n genl_family_rcv_msg net/netlink/genetlink.c:783 [inline]\n genl_rcv_msg+0x341/0x5a0 net/netlink/genetlink.c:800\n netlink_rcv_skb+0x14d/0x440 net/netlink/af_netlink.c:2497\n genl_rcv+0x29/0x40 net/netlink/genetlink.c:811\n netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]\n netlink_unicast+0x54b/0x800 net/netlink/af_netlink.c:1348\n netlink_sendmsg+0x914/0xe00 net/netlink/af_netlink.c:1916\n sock_sendmsg_nosec net/socket.c:651 [inline]\n __sock_sendmsg+0x157/0x190 net/socket.c:663\n ____sys_sendmsg+0x712/0x870 net/socket.c:2378\n ___sys_sendmsg+0xf8/0x170 net/socket.c:2432\n __sys_sendmsg+0xea/0x1b0 net/socket.c:2461\n do_syscall_64+0x30/0x40 arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x62/0xc7\nRIP: 0033:0x7f3f9815aee9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f3f972bf0c8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007f3f9826d050 RCX: 00007f3f9815aee9\nRDX: 0000000020000000 RSI: 0000000020001300 RDI: 0000000000000007\nRBP: 00007f3f981b63bd R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000006e R14: 00007f3f9826d050 R15: 00007ffe01ee6768\n\nIf drop_monitor is built as a kernel module, syzkaller may have time\nto send a netlink NET_DM_CMD_START message during the module loading.\nThis will call the net_dm_monitor_start() function that uses\na spinlock that has not yet been initialized.\n\nTo fix this, let's place resource initialization above the registration\nof a generic netlink family.\n\nFound by InfoTeCS on behalf of Linux Verification Center\n(linuxtesting.org) with Syzkaller.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/07b598c0e6f06a0f254c88dafb4ad50f8a8c6eea",
            "https://git.kernel.org/stable/c/0efa6c42f81c60d8f72ba7f5ed8d4fec8c526282",
            "https://git.kernel.org/stable/c/219a47d0e6195bd202f22855e35f25bd15bc4d58",
            "https://git.kernel.org/stable/c/29f9cdcab3d96d5207a5c92b52c40ad75e5915d8",
            "https://git.kernel.org/stable/c/6e9e0f224ffd8b819da3ea247dda404795fdd182",
            "https://git.kernel.org/stable/c/872c7c7e57a746046796ddfead529c9d37b9f6b4",
            "https://git.kernel.org/stable/c/b7859e8643e75619b2705b4fcac93ffd94d72b4a",
            "https://git.kernel.org/stable/c/fcfc00bfec7bb6661074cb21356d05a4c9470a3c"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21863",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring: prevent opcode speculation\n\nsqe->opcode is used for different tables, make sure we santitise it\nagainst speculations.",
        "Severity": "HIGH",
        "Patches": [
            "https://git.kernel.org/stable/c/1e988c3fe1264708f4f92109203ac5b1d65de50b",
            "https://git.kernel.org/stable/c/506b9b5e8c2d2a411ea8fe361333f5081c56d23a",
            "https://git.kernel.org/stable/c/b9826e3b26ec031e9063f64a7c735449c43955e4",
            "https://git.kernel.org/stable/c/fdbfd52bd8b85ed6783365ff54c82ab7067bd61b"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21864",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: drop secpath at the same time as we currently drop dst\n\nXiumei reported hitting the WARN in xfrm6_tunnel_net_exit while\nrunning tests that boil down to:\n - create a pair of netns\n - run a basic TCP test over ipcomp6\n - delete the pair of netns\n\nThe xfrm_state found on spi_byaddr was not deleted at the time we\ndelete the netns, because we still have a reference on it. This\nlingering reference comes from a secpath (which holds a ref on the\nxfrm_state), which is still attached to an skb. This skb is not\nleaked, it ends up on sk_receive_queue and then gets defer-free'd by\nskb_attempt_defer_free.\n\nThe problem happens when we defer freeing an skb (push it on one CPU's\ndefer_list), and don't flush that list before the netns is deleted. In\nthat case, we still have a reference on the xfrm_state that we don't\nexpect at this point.\n\nWe already drop the skb's dst in the TCP receive path when it's no\nlonger needed, so let's also drop the secpath. At this point,\ntcp_filter has already called into the LSM hooks that may require the\nsecpath, so it should not be needed anymore. However, in some of those\nplaces, the MPTCP extension has just been attached to the skb, so we\ncannot simply drop all extensions.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/69cafd9413084cd5012cf5d7c7ec6f3d493726d9",
            "https://git.kernel.org/stable/c/87858bbf21da239ace300d61dd209907995c0491",
            "https://git.kernel.org/stable/c/9b6412e6979f6f9e0632075f8f008937b5cd4efd",
            "https://git.kernel.org/stable/c/cd34a07f744451e2ecf9005bb7d24d0b2fb83656",
            "https://git.kernel.org/stable/c/f1d5e6a5e468308af7759cf5276779d3155c5e98"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21865",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngtp: Suppress list corruption splat in gtp_net_exit_batch_rtnl().\n\nBrad Spengler reported the list_del() corruption splat in\ngtp_net_exit_batch_rtnl(). [0]\n\nCommit eb28fd76c0a0 (\"gtp: Destroy device along with udp socket's netns\ndismantle.\") added the for_each_netdev() loop in gtp_net_exit_batch_rtnl()\nto destroy devices in each netns as done in geneve and ip tunnels.\n\nHowever, this could trigger ->dellink() twice for the same device during\n->exit_batch_rtnl().\n\nSay we have two netns A & B and gtp device B that resides in netns B but\nwhose UDP socket is in netns A.\n\n  1. cleanup_net() processes netns A and then B.\n\n  2. gtp_net_exit_batch_rtnl() finds the device B while iterating\n     netns A's gn->gtp_dev_list and calls ->dellink().\n\n  [ device B is not yet unlinked from netns B\n    as unregister_netdevice_many() has not been called. ]\n\n  3. gtp_net_exit_batch_rtnl() finds the device B while iterating\n     netns B's for_each_netdev() and calls ->dellink().\n\ngtp_dellink() cleans up the device's hash table, unlinks the dev from\ngn->gtp_dev_list, and calls unregister_netdevice_queue().\n\nBasically, calling gtp_dellink() multiple times is fine unless\nCONFIG_DEBUG_LIST is enabled.\n\nLet's remove for_each_netdev() in gtp_net_exit_batch_rtnl() and\ndelegate the destruction to default_device_exit_batch() as done\nin bareudp.\n\n[0]:\nlist_del corruption, ffff8880aaa62c00->next (autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc00/0x1000 [slab object]) is LIST_POISON1 (ffffffffffffff02) (prev is 0xffffffffffffff04)\nkernel BUG at lib/list_debug.c:58!\nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN\nCPU: 1 UID: 0 PID: 1804 Comm: kworker/u8:7 Tainted: G                T   6.12.13-grsec-full-20250211091339 #1\nTainted: [T]=RANDSTRUCT\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nWorkqueue: netns cleanup_net\nRIP: 0010:[<ffffffff84947381>] __list_del_entry_valid_or_report+0x141/0x200 lib/list_debug.c:58\nCode: c2 76 91 31 c0 e8 9f b1 f7 fc 0f 0b 4d 89 f0 48 c7 c1 02 ff ff ff 48 89 ea 48 89 ee 48 c7 c7 e0 c2 76 91 31 c0 e8 7f b1 f7 fc <0f> 0b 4d 89 e8 48 c7 c1 04 ff ff ff 48 89 ea 48 89 ee 48 c7 c7 60\nRSP: 0018:fffffe8040b4fbd0 EFLAGS: 00010283\nRAX: 00000000000000cc RBX: dffffc0000000000 RCX: ffffffff818c4054\nRDX: ffffffff84947381 RSI: ffffffff818d1512 RDI: 0000000000000000\nRBP: ffff8880aaa62c00 R08: 0000000000000001 R09: fffffbd008169f32\nR10: fffffe8040b4f997 R11: 0000000000000001 R12: a1988d84f24943e4\nR13: ffffffffffffff02 R14: ffffffffffffff04 R15: ffff8880aaa62c08\nRBX: kasan shadow of 0x0\nRCX: __wake_up_klogd.part.0+0x74/0xe0 kernel/printk/printk.c:4554\nRDX: __list_del_entry_valid_or_report+0x141/0x200 lib/list_debug.c:58\nRSI: vprintk+0x72/0x100 kernel/printk/printk_safe.c:71\nRBP: autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc00/0x1000 [slab object]\nRSP: process kstack fffffe8040b4fbd0+0x7bd0/0x8000 [kworker/u8:7+netns 1804 ]\nR09: kasan shadow of process kstack fffffe8040b4f990+0x7990/0x8000 [kworker/u8:7+netns 1804 ]\nR10: process kstack fffffe8040b4f997+0x7997/0x8000 [kworker/u8:7+netns 1804 ]\nR15: autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc08/0x1000 [slab object]\nFS:  0000000000000000(0000) GS:ffff888116000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000748f5372c000 CR3: 0000000015408000 CR4: 00000000003406f0 shadow CR4: 00000000003406f0\nStack:\n 0000000000000000 ffffffff8a0c35e7 ffffffff8a0c3603 ffff8880aaa62c00\n ffff8880aaa62c00 0000000000000004 ffff88811145311c 0000000000000005\n 0000000000000001 ffff8880aaa62000 fffffe8040b4fd40 ffffffff8a0c360d\nCall Trace:\n <TASK>\n [<ffffffff8a0c360d>] __list_del_entry_valid include/linux/list.h:131 [inline] fffffe8040b4fc28\n [<ffffffff8a0c360d>] __list_del_entry include/linux/list.h:248 [inline] fffffe8040b4fc28\n [<ffffffff8a0c360d>] list_del include/linux/list.h:262 [inl\n---truncated---",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/33eb925c0c26e86ca540a08254806512bf911f22",
            "https://git.kernel.org/stable/c/37e7644b961600ef0beb01d3970c3034a62913af",
            "https://git.kernel.org/stable/c/4ccacf86491d33d2486b62d4d44864d7101b299d",
            "https://git.kernel.org/stable/c/7f86fb07db65a470d0c11f79da551bd9466357dc",
            "https://git.kernel.org/stable/c/9d03e7e37187ae140e716377599493987fb20c5b",
            "https://git.kernel.org/stable/c/b70fa591b066d52b141fc430ffdee35b6cc87a66",
            "https://git.kernel.org/stable/c/cb15bb1bde0ba97cbbed9508e45210dcafec3657",
            "https://git.kernel.org/stable/c/ff81b14010362f6188ca26fec22ff05e4da45595"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:5.4.290:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:5.10.234:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:5.15.177:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2025-21866",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/code-patching: Fix KASAN hit by not flagging text patching area as VM_ALLOC\n\nErhard reported the following KASAN hit while booting his PowerMac G4\nwith a KASAN-enabled kernel 6.13-rc6:\n\n  BUG: KASAN: vmalloc-out-of-bounds in copy_to_kernel_nofault+0xd8/0x1c8\n  Write of size 8 at addr f1000000 by task chronyd/1293\n\n  CPU: 0 UID: 123 PID: 1293 Comm: chronyd Tainted: G        W          6.13.0-rc6-PMacG4 #2\n  Tainted: [W]=WARN\n  Hardware name: PowerMac3,6 7455 0x80010303 PowerMac\n  Call Trace:\n  [c2437590] [c1631a84] dump_stack_lvl+0x70/0x8c (unreliable)\n  [c24375b0] [c0504998] print_report+0xdc/0x504\n  [c2437610] [c050475c] kasan_report+0xf8/0x108\n  [c2437690] [c0505a3c] kasan_check_range+0x24/0x18c\n  [c24376a0] [c03fb5e4] copy_to_kernel_nofault+0xd8/0x1c8\n  [c24376c0] [c004c014] patch_instructions+0x15c/0x16c\n  [c2437710] [c00731a8] bpf_arch_text_copy+0x60/0x7c\n  [c2437730] [c0281168] bpf_jit_binary_pack_finalize+0x50/0xac\n  [c2437750] [c0073cf4] bpf_int_jit_compile+0xb30/0xdec\n  [c2437880] [c0280394] bpf_prog_select_runtime+0x15c/0x478\n  [c24378d0] [c1263428] bpf_prepare_filter+0xbf8/0xc14\n  [c2437990] [c12677ec] bpf_prog_create_from_user+0x258/0x2b4\n  [c24379d0] [c027111c] do_seccomp+0x3dc/0x1890\n  [c2437ac0] [c001d8e0] system_call_exception+0x2dc/0x420\n  [c2437f30] [c00281ac] ret_from_syscall+0x0/0x2c\n  --- interrupt: c00 at 0x5a1274\n  NIP:  005a1274 LR: 006a3b3c CTR: 005296c8\n  REGS: c2437f40 TRAP: 0c00   Tainted: G        W           (6.13.0-rc6-PMacG4)\n  MSR:  0200f932 <VEC,EE,PR,FP,ME,IR,DR,RI>  CR: 24004422  XER: 00000000\n\n  GPR00: 00000166 af8f3fa0 a7ee3540 00000001 00000000 013b6500 005a5858 0200f932\n  GPR08: 00000000 00001fe9 013d5fc8 005296c8 2822244c 00b2fcd8 00000000 af8f4b57\n  GPR16: 00000000 00000001 00000000 00000000 00000000 00000001 00000000 00000002\n  GPR24: 00afdbb0 00000000 00000000 00000000 006e0004 013ce060 006e7c1c 00000001\n  NIP [005a1274] 0x5a1274\n  LR [006a3b3c] 0x6a3b3c\n  --- interrupt: c00\n\n  The buggy address belongs to the virtual mapping at\n   [f1000000, f1002000) created by:\n   text_area_cpu_up+0x20/0x190\n\n  The buggy address belongs to the physical page:\n  page: refcount:1 mapcount:0 mapping:00000000 index:0x0 pfn:0x76e30\n  flags: 0x80000000(zone=2)\n  raw: 80000000 00000000 00000122 00000000 00000000 00000000 ffffffff 00000001\n  raw: 00000000\n  page dumped because: kasan: bad access detected\n\n  Memory state around the buggy address:\n   f0ffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n   f0ffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  >f1000000: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n             ^\n   f1000080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n   f1000100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n  ==================================================================\n\nf8 corresponds to KASAN_VMALLOC_INVALID which means the area is not\ninitialised hence not supposed to be used yet.\n\nPowerpc text patching infrastructure allocates a virtual memory area\nusing get_vm_area() and flags it as VM_ALLOC. But that flag is meant\nto be used for vmalloc() and vmalloc() allocated memory is not\nsupposed to be used before a call to __vmalloc_node_range() which is\nnever called for that area.\n\nThat went undetected until commit e4137f08816b (\"mm, kasan, kmsan:\ninstrument copy_from/to_kernel_nofault\")\n\nThe area allocated by text_area_cpu_up() is not vmalloc memory, it is\nmapped directly on demand when needed by map_kernel_page(). There is\nno VM flag corresponding to such usage, so just pass no flag. That way\nthe area will be unpoisonned and usable immediately.",
        "Severity": "MEDIUM",
        "Patches": [
            "https://git.kernel.org/stable/c/2d542f13d26344e3452eee77613026ce9b653065",
            "https://git.kernel.org/stable/c/2e6c80423f201405fd65254e52decd21663896f3",
            "https://git.kernel.org/stable/c/6847b3e40bb963e57b61d1cc6fe84cb37b9d3d4c",
            "https://git.kernel.org/stable/c/8d06e9208184b2851fa79a3a39d6860320c8bdf8",
            "https://git.kernel.org/stable/c/97de5852058a299ba447cd9782fe96488d30108b",
            "https://git.kernel.org/stable/c/c905a3053518212a1017e50bd2be3bee59305bb0",
            "https://git.kernel.org/stable/c/d262a192d38e527faa5984629aabda2e0d1c4f54",
            "https://git.kernel.org/stable/c/f8d4c5b653c1bc0df56e15658bbf64fc359adc4e"
        ],
        "Security Advisories": [],
        "Affected Systems": [
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*",
            "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*"
        ]
    },
    {
        "CVE ID": "CVE-2023-52927",
        "Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: allow exp not to be removed in nf_ct_find_expectation\n\nCurrently nf_conntrack_in() calling nf_ct_find_expectation() will\nremove the exp from the hash table. However, in some scenario, we\nexpect the exp not to be removed when the created ct will not be\nconfirmed, like in OVS and TC conntrack in the following patches.\n\nThis patch allows exp not to be removed by setting IPS_CONFIRMED\nin the status of the tmpl.",
        "Severity": "N/A",
        "Patches": [
            "https://git.kernel.org/stable/c/3fa58a6fbd1e9e5682d09cdafb08fba004cb12ec",
            "https://git.kernel.org/stable/c/4914109a8e1e494c6aa9852f9e84ec77a5fc643f"
        ],
        "Security Advisories": [],
        "Affected Systems": []
    }
]